'use strict';(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/Mjolnir/docs/installation/",title:"Installation",section:"Docs",content:"Installation #  This page describes how to build Mjolnir.\nPrerequisities #   linux or Unix (e.g. OS X) C++11 compatible compiler git Make CMake Boost C++ Library  Operating System #  It assumes that the file pathes conform to the posix standard.\nAlso, automatic tests only run on Linux and OS X. Thus it is not guaranteed to work on Windows properly.\nC++ compiler #  It requires C++11 compatible compiler. Since now it is 2021, default compilers in most of the systems are compatible to C++11.\nBut I recommend to use the later versions of compilers. Compilers are also in development, so the later versions generally have less bugs and generate faster executables.\nGit #  Mjolnir contains toml11 library as a git-submodule. Git is required to download it.\nCMake #  Mjolnir uses CMake as a build system.\nThe CMakeLists.txts expects relatively later versions of CMake. So it is recommended to use the later versions of CMake.\nBoost #  Test codes of Mjolnir depends on the Boost library.\nAlthough CMakeLists.txt automatically downloads Boost, it makes build process faster to use a library that is already built.\nBuilding #  To build Mjolnir, run the following commands.\n$ git clone https://github.com/Mjolnir-MD/Mjolnir.git $ cd Mjolnir $ mkdir build $ cd build $ cmake .. # commonly-used options are listed below. $ make $ make test Example CMake Options #   To change the compiler to be used  $ cmake .. -DCMAKE_CXX_COMPILER=clang++  To use Boost library installed in your system  $ cmake .. -DFIND_BOOST=ON -DBOOST_ROOT=/path/to/boost  To speedup compilation by turning separated build on and also using pre-built boost library  $ cmake .. -DSEPARATE_BUILD=ON -DFIND_BOOST=ON -DBOOST_ROOT=/path/to/boost Options for CMake #  All those are optional variables.\n -DCMAKE_CXX_COMPILER=/path/to/compiler  It is an option for CMake. You can choose what compiler would be used.   -DUSE_OPENMP=(ON|OFF)  ON by default. If ON, compile with OpenMP (if it is available). Then you can parallelize your simulation with OpenMP.   -DFIND_BOOST=(ON|OFF)  OFF by default. If ON, CMake looks boost library that is already installed. If it does not exist, the build fails.   -DBOOST_ROOT=/path/to/boost  It is an option for FindBoost package in CMake. You can specify the path to boost you want to use.   -DSEPARATE_BUILD=(ON|OFF)  OFF by default. If ON, compile codes separately and link them after compilation. This feature is for developers who compiles it a lot of times.   -DSINGLE_PRECISION_SUPPORT=(ON|OFF)  ON by default. If OFF, float version of the code will be ignored and the compilation finishes quickly.   -DDOUBLE_PRECISION_SUPPORT=(ON|OFF)  ON by default. If OFF, double version of the code will be ignored and the compilation finishes quickly.   -DUNLIMITED_BOUNDARY_SUPPORT=(ON|OFF)  ON by default. If OFF, UnlimitedBoundary would not be able to be used, but the compilation finishes quickly.   -DPERIODIC_BOUNDARY_SUPPORT=(ON|OFF)  ON by default. If OFF, CuboidalPeriodicBoundary would not be able to be used, but the compilation finishes quickly.   -DBUILD_UNIT_TEST=(ON|OFF)  ON by default. If OFF, unit tests would not be compiled. It will save your time.   -DBUILD_INTEGRATION_TEST=(ON|OFF)  OFF by default. If ON, integration tests will be compiled.    "}),e.add({id:1,href:"/Mjolnir/docs/reference/",title:"Reference",section:"Docs",content:"Reference #  Mjolnir does not have any command-line option. It uses a TOML file as the input. So a command to execute simulation looks like the following.\n$ ./bin/mjolnir sample.toml This document introduces how to write an input file. Here, a brief introduction of major components in an input file are provided.\nFor detailed information about TOML v1.0.0, the file format used in Mjolnir, can be found in the toml-lang official site.\nAn input file for Mjolnir has of 5 main components. Each of them is a table or an array of tables.\n[files] #  It specifies the output path, filename, and format. It also specify input path if required.\n[units] #  It specifies a set of units to be used, e.g. angstrom, kJ/mol, etc.\nThe values of energies, positions, distances that would be provided later, are considered to be expressed in this units.\n[simulator] #  It specifies a protocol of a simulation.\nE.g., which floating-point would be used, what boundary condition would be used, how many timesteps does it simulate, etc.\nYou can provide this table as another toml file by specifying only a filename.\n[[systems]] #  It specifies a set of particles, boundary shape, system parameters such as temperature, ionic strength, etc.\nIt is defined as an array of table for some kinds of simulations that uses several replicas of simulation box. But in the normal case, only one [[systems]] are required.\nYou can provide this table as another toml file by specifying only a filename.\n[[forcefields]] #  It specifies forcefield parameters.\nIt is defined as an array of table for some kinds of simulations that uses several different forcefields. But in the normal case, only one [[forcefields]] are required.\nYou can provide this table as another toml file by specifying only a filename.\nIncluding different files #  Everywhere in the input file, a value corresponding to the key, include, has a special meaning.\nA value corresponds to include is a string or an array of strings, specifying filenames. The path would be specified via input.path value in the [files] table.\nIf include is specified, the values defined in those specified toml files will be merged under the table that has include.\nIn the following case,\n# main.toml [[forcefields]] include = [  \u0026#34;bond-length.toml\u0026#34;,  # other forcefields ... ] # bond-length.toml [[local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; parameters = [  # ... ] The file internally becomes to the following.\n[[forcefields]] [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; parameters = [  # ... ] Note that Mjolnir expands those include files only once.\n"}),e.add({id:2,href:"/Mjolnir/docs/tutorial/",title:"Tutorial",section:"Docs",content:"Tutorial #  The Lennard-Jones fluid #  First, the way to define global (a.k.a. non-local) interaction is explained through simulation of the Lennard-Jones fluid.\nA Simple Polymer Model #  Next, the way to define local interaction is explained through simulation of a simple polymer model.\n"}),e.add({id:3,href:"/Mjolnir/docs/developersguide/",title:"Developer's Guide",section:"Docs",content:"Developer\u0026rsquo;s Guide #  It explains how to add a new simulation protocols or forcefields.\nDesign Philosophy #  (Under construction)\nComponents Overview #  (Under construction)\n"}),e.add({id:4,href:"/Mjolnir/docs/glossary/",title:"Glossary",section:"Docs",content:"Glossary #  Simulator #  Simulator implements a simulation protocol.\nMolecularDynamicsSimulator just performs time integration using given integrator, forcefields and systems.\nSimulatedAnnealingSimulator also performs time integration and changes temperature of the system in the specified manner.\nSwitchingForceFieldSimulator manages multiple forcefields and swaps the active forcefield at the specified timestep.\nThe actual force and time integral calculations are performed by another component managed by the Simulator.\nSystem #  A group of particles to be simulated.\nIn addition to particles, it also manages boundary conditions, system parameters (such as temperature), and Topology.\nTopology #  This is a (mathematical) graph showing which particles are connected by which interaction.\nIt is used in a ForceField to check particles are already connected.\nIntegrator #  Integrator performs time integration.\nForceField #  There are three types: local, global, and external.\nLocalForceField #  It is an interaction between specific particles.\nTypical examples are bond length potential, bond angle potential, and dihedral potential.\nGlobalForceField #  It is an interaction between all the combinations of particles.\nTypical examples are intermolecular force potential and electrostatic potential.\nExternalForceField #  It is an interaction between particles and the external field.\nOnly this can cause translation and rotation of the entire system.\nTypical examples are anchors to specific points in the space and boxes that cover the entire system.\nInteraction #  ForceField consists of Interaction and Potential.\nInteraction manages on which particle the potential will be applied.\nWhen there is a force field like\n  \\[U(\\theta) = k(\\theta-\\theta_0)^2,\\]  the force becomes the following.\n \\[\\nabla_i U(\\theta) = \\color{red}(\\nabla_i \\theta) \\color{black} \\frac{dU}{d\\theta}\\]  It implements the first term that is colored red.\nPotential #  ForceField consists of Interaction and Potential.\nPotential manages the parameters related to the potential function and calculates the potential function and the derivative.\nWhen there is a force field like\n \\[U(\\theta) = k (\\theta - \\theta_0)^2,\\]  the force becomes the following.\n \\[\\nabla_i U(\\theta) = (\\nabla_i \\theta) \\color{red} \\frac{dU}{d\\theta}\\]  It implements the second term that is colored red.\nObserver #  Observer outputs energy, particle position, and velocity to a file.\nTraits #  A tag type to dispatch the implementations.\nFor example, codes needed only for OpenMP are specialized with OpenMPSimulatorTraits.\n"}),e.add({id:5,href:"/Mjolnir/docs/reference/files/",title:"Files",section:"Reference",content:"[files] #  Here, you can control pathes and outpu file name and format.\nExample #  [files] output.path = \u0026#34;data/\u0026#34; output.prefix = \u0026#34;protein1\u0026#34; output.format = \u0026#34;xyz\u0026#34; output.progress_bar = false input.path = \u0026#34;input/\u0026#34; Input Reference #  files table has 2 sub-tables, named output and input.\nfiles.output #   prefix: String  Filename without extension. The name output file will be {prefix}.log or something like that.   path: String  The path where output files will be created. The directory must exist before running Mjolnir.   format: String  Format of the trajectory file. One of the following. \u0026quot;xyz\u0026quot; \u0026quot;dcd\u0026quot; \u0026quot;trr\u0026quot; If xyz or dcd is chosen, {prefix}_position and {prefix}_velocity will be created.   progress_bar: Bool (Optional. By default, true.)  If true, progress bar will be printed. If the output is redirected to a file, Mjolnir automatically suppresses it.    files.input #   path: String (Optional. By default, \u0026quot;.\u0026quot;)  The path where Mjolnir look for files included.    "}),e.add({id:6,href:"/Mjolnir/docs/tutorial/lennard-jones/",title:"The Lennard-Jones fluid",section:"Tutorial",content:"The Lennard-Jones fluid #  As a simple example, we will run a molecular dynamics simulation of particles interacting via Lennard-Jones potential. We want to make the system small so that the simulation does not takes long time, we put only 512 particles. Also, our goal is not a simulation of a specific atom but just to run a simulation, so we keep parameters simple.\nWe need the following information to run a simulation.\n Simulation method Initial configuration Forcefield parameters  We will write those information and save it in an input file named lennard-jones.toml.\n[files] and [units] #  First of all, we will define the output file name and format. To make it simple, we use xyz format.\n[files] output.prefix = \u0026#34;lennard-jones\u0026#34; output.path = \u0026#34;./\u0026#34; output.format = \u0026#34;xyz\u0026#34; To see the complete list of available options, see files section in the reference.\nAlso, we need to define unit system to be used.\n[units] length = \u0026#34;angstrom\u0026#34; energy = \u0026#34;kcal/mol\u0026#34; To see the complete list of available options, see units section in the reference.\n[simulator] and other general properties #  We have defined general settings, so next we will define the simulation method.\nWe will perform normal molecular dynamics simulation, so the type of simulator is MolecularDynamics. We will apply the periodic boundary conditions so that the simulated particles are enclosed in a box. And, while the simulation, we use double precision floating point. We also need to set the seed of random number generator.\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; precision = \u0026#34;double\u0026#34; boundary_type = \u0026#34;Periodic\u0026#34; seed = 123456789 The integrator is also needed. Here, we use BAOAB-type Langevin integrator that is introduced relatively recently. We can set the friction coefficient one by one, but for now, we just set 1 for all the particles.\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; precision = \u0026#34;double\u0026#34; boundary_type = \u0026#34;Periodic\u0026#34; seed = 123456789 delta_t = 0.01 total_step = 100_000 save_step = 100 integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  {index = 0, gamma = 1.00},  {index = 1, gamma = 1.00},  {index = 2, gamma = 1.00},  # ...  {index = 511, gamma = 1.00}, ] It is a hard work. But keyboard macro supported by the editor or a simple script can help you to generate it.\nTo see the complete list of available options, see Simulator section in the reference.\n[[systems]] #  To run a simulation, we need a reasonable initial configuration. Initial configuration is defined in [[systems]].\nFirst, we will define a general parameter. The temperature of the system and the shape of periodic boundary.\n[[systems]] attributes.temperature = 300.0 # K boundary_shape.lower = [ 0.0, 0.0, 0.0] boundary_shape.upper = [16.0, 16.0, 16.0] To avoid collisions, we put particles on grid points separating them by 2 angstroms, assuming they have radius of 1 angstrom..\n[[systems]] attributes.temperature = 300.0 # K boundary_shape.lower = [ 0.0, 0.0, 0.0] boundary_shape.upper = [16.0, 16.0, 16.0] particles = [  {mass = 1.0, position = [ 1.000, 1.000, 1.000]},  {mass = 1.0, position = [ 3.000, 1.000, 1.000]},  {mass = 1.0, position = [ 5.000, 1.000, 1.000]},  {mass = 1.0, position = [ 7.000, 1.000, 1.000]},  {mass = 1.0, position = [ 9.000, 1.000, 1.000]},  {mass = 1.0, position = [11.000, 1.000, 1.000]},  {mass = 1.0, position = [13.000, 1.000, 1.000]},  {mass = 1.0, position = [15.000, 1.000, 1.000]},   {mass = 1.0, position = [ 1.000, 3.000, 1.000]},  {mass = 1.0, position = [ 3.000, 3.000, 1.000]},  {mass = 1.0, position = [ 5.000, 3.000, 1.000]},  {mass = 1.0, position = [ 7.000, 3.000, 1.000]},  {mass = 1.0, position = [ 9.000, 3.000, 1.000]},  {mass = 1.0, position = [11.000, 3.000, 1.000]},  {mass = 1.0, position = [13.000, 3.000, 1.000]},  {mass = 1.0, position = [15.000, 3.000, 1.000]},  # 続く... ] To see the complete list of available options, see Systems section in the reference.\n[[forcefields]] #  Finally, we will define forcefield parameters.\nLennard-Jones interaction is applied to all the pair of particles, so it is non-local interaction. To distinguish from external force field, we call it as a global interaction. So first define a [[forcefields.global]] under the [[forcefields]] table and specify the interaction type and the potential function.\n[[forcefields]] [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJones\u0026#34; Next, we will specify the spatial partitioning method. In this example, our system could be too small to construct an efficient cell list. So we use raw Verlet list.\nVerlet list takes a margin to reduce the computational cost without changing the simulation result. By taking particles that is a bit distant from cutoff region account, the list can be reused until a particle that is not registered in a list comes into the cutoff region.\nThe margin is defined relative to the cutoff length. To tune it, we need to run several short simulations with varying margin. But since this does not change the trajectory, any value is basically okay (if the simulation doesn\u0026rsquo;t take too long time).\n[[forcefields]] [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJones\u0026#34; spatial_partition.type = \u0026#34;VerletList\u0026#34; spatial_partition.margin = 0.25 And of course, we need a forcefield parameter for each particle.\n[[forcefields]] [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJones\u0026#34; spatial_partition.type = \u0026#34;VerletList\u0026#34; spatial_partition.margin = 0.25 parameters = [  {index = 0, sigma = 2.0, epsilon = 1.0},  {index = 1, sigma = 2.0, epsilon = 1.0},  {index = 2, sigma = 2.0, epsilon = 1.0},  # ...  {index = 511, sigma = 2.0, epsilon = 1.0}, ] The actual parameter for each pair or particles is calculated according to the Lorentz-Berthelot combining rule.\nTo see the complete list of available options, see ForceFields section in the reference.\nSimulation #  Congratulations! All the required information is written in the input file. By passing the input file to mjolnir, it runs the simulation. It takes a few minutes, depending on the machine you are using.\n$ ./bin/mjolnir lennard-jones.toml reading input file... -- reading and parsing toml file `lennard-jones.toml` ... successfully parsed. -- the log file is `./lennard-jones.log` -- mjolnir version v1.22.0 -- compiled using /usr/bin/g++-10 -- input_path is ./ -- expanding include files ... -- done. -- precision is double -- Boundary Condition is Periodic. The shape is cuboid. -- execute on single core -- energy unit is [kcal/mol] -- length unit is [angstrom] -- Integrator is BAOABLangevin. -- Simulator type is MolecularDynamics. -- total step is 100000 -- save step is 100 -- checkpoint step is 100 -- reading 0th system ... -- 512 particles are found. -- output file prefix is `./lennard-jones` -- output xyz format. -- GlobalForceField (x1) found -- reading 0th [[forcefields.global]] -- Pair interaction found. -- -- potential function is Lennard-Jones. -- -- Spatial Partition is VerletList with relative margin = 0.25 -- No `ignore.group` is provided. All the groups are taken into account. -- No `ignore.molecule` is provided. All the molecules are taken into account. -- seed is 123456789 done. initializing simulator... -- generating velocity with T = 300... -- done. done. start running simulation 14.1%|███████ | 56.0 seconds remaining You will find the following files after the simulation is complete.\n$ ls lennard-jones* lennard-jones.toml lennard-jones.log lennard-jones.ene lennard-jones_position.xyz lennard-jones_velocity.xyz lennard-jones_system.msg lennard-jones_rng.msg The .msg files are for restarting simulation. The format is MsgPack.\nThe .ene file has the value of energies and other physical quantities in a simple ASCII format, and you can easily visualize it by using gnuplot or other software or a library.\n$ head lennard-jones.ene # unit of length : angstrom, unit of energy : kcal/mol # timestep GlobalPairLennardJones kinetic_energy attribute:temperature 0 -1704.786330 453.454993 300.000000 100 -2579.996798 812.198804 300.000000 200 -2787.935537 554.446648 300.000000 300 -2909.224864 473.619251 300.000000 400 -2913.189150 453.464065 300.000000 500 -2964.234777 463.400579 300.000000 600 -2988.270454 462.704726 300.000000 700 -2960.111833 458.723132 300.000000 lennard-jones_position.xyz contains the trajectory. You can visualize it by passing the file to a VMD or molecular viewer.\nConclusion #  This tutorial is over.\nYou might feel the input file is too explicit. But, it allows you to easily change the forcefield parameter one by one. You can increase the size of one particular particle, or mix different-sized particles. If you are interested, have fun with it.\n"}),e.add({id:7,href:"/Mjolnir/docs/tutorial/polymer-model/",title:"A simple polymer model",section:"Tutorial",content:"A simple polymer model #  This time, we will run a molecular dynamics simulation of 100 particles connected by springs.\n[files] and [units] #  Same as the previous example, we first define the names and the format of output files.\n[files] output.prefix = \u0026#34;polymer-model\u0026#34; output.path = \u0026#34;./\u0026#34; output.format = \u0026#34;xyz\u0026#34; To see the complete list of available options, see files section in the reference.\nAlso, we need to define unit system to be used.\n[units] length = \u0026#34;angstrom\u0026#34; energy = \u0026#34;kcal/mol\u0026#34; To see the complete list of available options, see units section in the reference.\n[simulator] #  Unlike the previous example, here, all the particles are connected by springs, so we can omit periodic boundary without worrying that some of the particles will go far away.\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; precision = \u0026#34;double\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; # No periodic boundary seed = 123456789 delta_t = 0.01 total_step = 1_000_000 save_step = 1_000 integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  {index = 0, gamma = 1.00},  {index = 1, gamma = 1.00},  {index = 2, gamma = 1.00},  # ...  {index = 99, gamma = 1.00}, ] Most of the parts are the same as the previous example.\nTo see the complete list of available options, see Simulator section in the reference.\n[[systems]] #  This time, we don\u0026rsquo;t need boundary_shape because we don\u0026rsquo;t have a periodic boundary.\nLet\u0026rsquo;s place particles along a straight line.\n[[systems]] attributes.temperature = 300.0 # K particles = [  {mass = 1.0, position = [ 0.000, 0.000, 0.000]},  {mass = 1.0, position = [ 1.000, 0.000, 0.000]},  {mass = 1.0, position = [ 2.000, 0.000, 0.000]},  {mass = 1.0, position = [ 3.000, 0.000, 0.000]},  {mass = 1.0, position = [ 4.000, 0.000, 0.000]},  {mass = 1.0, position = [ 5.000, 0.000, 0.000]},  {mass = 1.0, position = [ 6.000, 0.000, 0.000]},  {mass = 1.0, position = [ 7.000, 0.000, 0.000]},  {mass = 1.0, position = [ 8.000, 0.000, 0.000]},  # 続く...  {mass = 1.0, position = [99.000, 0.000, 0.000]}, ] To see the complete list of available options, see Systems section in the reference.\n[[forcefields]] #  Finally, we will define forcefield parameters.\nIn this example, we want to connect particles by springs. So we define a \u0026ldquo;local\u0026rdquo; forcefield.\n[[forcefields]] [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;bond\u0026#34; topology, later it will be explained in detail, is a label to handle relationships between local and global interactions. In this case, the name is not important.\nThen, apply local potentials between particles. BondLength interaction takes two particles. Harmonic potential takes v0 and k. v0 is the value where the potential takes the minimum. k is the value which determines the strength of the potential.\n[[forcefields]] [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [ 0, 1], v0 = 1.0, k = 10.0},  {indices = [ 1, 2], v0 = 1.0, k = 10.0},  {indices = [ 2, 3], v0 = 1.0, k = 10.0},  # ...  {indices = [98,99], v0 = 1.0, k = 10.0}, ] To see the complete list of available options, see ForceFields section in the reference.\nSimulation #  Congratulations! All the required information is written in the input file. By passing the input file to mjolnir, it runs the simulation.\nIt takes relatively short time compared to the previous example because we have less particles.\n$ ./bin/mjolnir polymer-model.toml reading input file... -- reading and parsing toml file `polymer-model.toml` ... successfully parsed. -- the log file is `./polymer-model.log` -- mjolnir version v1.22.0-dev (06d5ede6) -- compiled using /usr/bin/g++-10 -- input_path is ./ -- expanding include files ... -- done. -- precision is double -- Boundary Condition is Unlimited -- execute on single core -- energy unit is [kcal/mol] -- length unit is [angstrom] -- Integrator is BAOABLangevin. -- Simulator type is MolecularDynamics. -- total step is 1000000 -- save step is 1000 -- checkpoint step is 1000 -- reading 0th system ... -- 100 particles are found. -- output file prefix is `./polymer-model` -- output xyz format. -- LocalForceField (x1) found -- reading 0th [[forcefields.local]] -- Bond Length interaction found. -- -- potential function is Harmonic. -- -- 99 interactions are found. -- seed is 123456789 done. initializing simulator... -- generating velocity with T = 300... -- done. done. start running simulation 8.2%|████ | 10.5 seconds remaining You will find the following files after the simulation is complete.\n$ ls polymer-model* polymer-model.toml polymer-model.ene polymer-model.log polymer-model_rng.msg polymer-model_system.msg polymer-model_position.xyz polymer-model_velocity.xyz The .msg files are for restarting simulation. The format is MsgPack.\nThe .ene file has the value of energies and other physical quantities in a simple ASCII format, and you can easily visualize it by using gnuplot or other software or a library.\n$ head polymer-model.ene # unit of length : angstrom, unit of energy : kcal/mol # timestep BondLength:Harmonic kinetic_energy attribute:temperature 0 0.000000 96.956625 300.000000 1000 56.910239 86.124451 300.000000 2000 51.497857 85.960034 300.000000 3000 44.394914 90.433666 300.000000 4000 50.774066 89.091169 300.000000 5000 46.749105 104.594276 300.000000 6000 34.130104 86.045558 300.000000 7000 39.505721 84.893861 300.000000 polymer-model_position.xyz contains the trajectory. You can visualize it by passing the file to a VMD or molecular viewer.\nConclusion #  This tutorial is over.\nWe passed two particles to each BondLegnth interaction. Those two are not necessarily be contiguous. You can apply potential on any pair of particles.\nBondAngle and DihedralAngle is also a LocalInteraction. Mjolnir supports those in the same way as BondLength. If you are interested, see LocalForceField.\n"}),e.add({id:8,href:"/Mjolnir/docs/reference/units/",title:"Units",section:"Reference",content:"[units] #  All the energy values, length, positions have the units defined here.\nExample #  [units] length = \u0026#34;angstrom\u0026#34; energy = \u0026#34;kcal/mol\u0026#34; Input Reference #  [units] #   energy: String  \u0026quot;kcal/mol\u0026quot; or \u0026quot;kJ/mol\u0026quot;   length: String  \u0026quot;nm\u0026quot; or \u0026quot;angstrom\u0026quot;    The unit of mass is AMU and the unit of charge is   \\( e \\)  (elementary charge). Currently, unit of mass and charge cannot be changed.\nThe unit of time will be calculated from the above unit system. For example, with \u0026quot;kcal/mol\u0026quot; and \u0026quot;angstrom\u0026quot;, 1 unit-time will be approximately 49 fs.  "}),e.add({id:9,href:"/Mjolnir/docs/reference/simulators/",title:"Simulators",section:"Reference",content:"[simulator] #  [simulator] table defines what kind of simulation it will perform.\nInput Reference #  Common Part #  Some of the fields are common to all the simulators.\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; boundary_type = \u0026#34;Periodic\u0026#34; precision = \u0026#34;double\u0026#34; parallelism = \u0026#34;OpenMP\u0026#34; # optional  type: String  It defines simulation method. E.g. simulated annealing, steepest descent, etc. See the following section, \u0026ldquo;Available Simulators\u0026rdquo;.   boundary_type: String  \u0026quot;Unlimited\u0026quot;: No boundary will be applied. \u0026quot;Periodic\u0026quot;: It applies periodic boundary of which shape is recutangular box. \u0026quot;PeriodicCuboid\u0026quot;: The same as the previous option.   precition: String  \u0026quot;float\u0026quot;: Use 32-bit floating point type. \u0026quot;double\u0026quot;: Use 64-bit floating point type.   parallelism: String (Optional. By default, \u0026quot;sequencial\u0026quot;.)  \u0026quot;OpenMP\u0026quot;: Use OpenMP implementation. \u0026quot;sequencial\u0026quot;: Run on single core.   forcefield: Table (Optional. By default, none.)  For detail, see MultipleBasinForceField.    Available Simulators #   MolecularDynamics  It performs normal molecular dynamics simulation.   SimulatedAnnealing  It performs simulated annealing simulation with given forcefield.   SteepestDescent  It performs steepest descent method with given forcefield.   SwitchingForceField  It performs normal molecular dynamics simulation but changes forcefields as scheduled order.   EnergyCalculation  It does not perform any simulation but calculates energy from trajectory with given forcefield.    "}),e.add({id:10,href:"/Mjolnir/docs/reference/integrators/",title:"Integrators",section:"Reference",content:"Integrator #  G-JFLangevin #  It performs a NVT simulation according to Langevin equation.\nIt is developed by the following paper.\n Niels Grønbech-Jensen \u0026amp; Oded Farago, (2013) Mol.Phys. 111:8, 983-991  BAOABLangevin #  It performs a NVT simulation according to Langevin equation.\nIt is developed by the following paper.\n Benedict Leimkuhler and Charles Matthews. Appl. Math. Res. Exp. (2013) 2013:1, pp. 34-56 Benedict Leimkuhler and Charles Matthews. J. Chem. Phys. (2013) 138:17, 174102  g-BAOABLangevin #  It performs a NVT simulation according to Langevin equation. It is capable of handling constraints.\nIt is developed by the following paper.\n Leimkuhler B, Matthews C. Proc. R. Soc. A. (2016) 472:20160138  GFWNPTLangevin #  It performs NPT Langevin simulation.\nIt is introduced in the following paper.\n Xingyu Gao, Jun Fang, and Han Wang. J. Chem. Phys. (2016) 144, 124113  UnderdampedLangevin #  It performs a NVT simulation according to Langevin equation.\nIt is introduced in the following papers.\n J. D. Honeycutt and D. Thirumalai, (1992) Biopolymers Z. Guo and D. Thirumalai, (1995) Biopolymers.  It is the same method that is employed in CafeMol.\nVelocityVerlet #  It performs constant energy simulation according to Newtonian equation.\n"}),e.add({id:11,href:"/Mjolnir/docs/reference/system/",title:"System",section:"Reference",content:"System #  You can define positions, velocities, masses of particles, box size of a system, and other parameters for the whole system.\nIt is defined as an array of tables to define several replicas of a system. But normally, only one system is enough.\nExample #  [[systems]] attributes.temperature = 300.0 boundary_shape.lower = [ 0.0, 0.0, 0.0] # lower limit of the boundary boundary_shape.upper = [100.0, 100.0, 100.0] # upper limit of the boundary particles = [  {m= 1.0, pos=[ 1.000, 2.000, -1.000], vel=[ 0.100,-0.200, 0.300], name=\u0026#34;CA\u0026#34;, group=\u0026#34;A\u0026#34;},  # ... ] Input reference #   boundary_shape: Table  shape of the boundary. e.g. upper and lower. You can omit this if the boundary type is \u0026quot;Unlimited\u0026quot;.   attributes: Table  parameters of a system. e.g. reference temperature for a thermostat.   particles: Array of Tables  The initial configuration of particles.    boundary_shape for \u0026quot;Periodic\u0026quot; boundary #  lower and upper coordinates of the box is required.\n lower: Array of Floatings (length == 3)  The lower boundary of the box.   upper: Array of Floatings (length == 3)  The upper boundary of the box.    boundary_shape.lower = [ 0.0, 0.0, 0.0] boundary_shape.upper = [100.0, 100.0, 100.0] attribute #  You can define parameters of the whole system.\nSome forcefields, integrators, and simulators require some specific attributes.\n temperature: Floating  The reference temperature of the system in [K]. NVT integrators (e.g. BAOABLangevin) requires this parameter.   ionic_strength: Floating  The ionic strength of the system in [mol/L]. DebyeHuckel potential requires this.    particles #  The initial configuration of the particles.\nEach particle has mass, position, velocity (optional), name (optional), and group (optional).\nparticles = [  {mass = 1.0, position = [1.0, 2.0, 3.0], velocity = [1.0, 2.0, 3.0], name = \u0026#34;A\u0026#34;, group = \u0026#34;G\u0026#34;},  # ... ] Since there are many fields, you can use shortened keys.\nparticles = [  {m = 1.0, pos = [1.0, 2.0, 3.0], vel = [1.0, 2.0, 3.0], name = \u0026#34;A\u0026#34;, group = \u0026#34;G\u0026#34;},  # ... ] Also, you can omit velocities. In that case, the initial velocities are generated according to Maxwell-Boltzmann distribution.\nparticles = [  {m = 1.0, pos = [1.0, 2.0, 3.0], name = \u0026#34;A\u0026#34;, group = \u0026#34;G\u0026#34;},  # ... ] Restarting from the last snapshot of another simulation #  Mjolnir saves the whole snapshot of a system in MsgPack format.\nBy passing a .msg file, you can load the whole state of the system.\n[[systems]] file_name = \u0026#34;restart.msg\u0026#34; "}),e.add({id:12,href:"/Mjolnir/docs/reference/forcefields/",title:"ForceFields",section:"Reference",content:"[[forcefields]] #  ForceField is a set of potential energy functions applied to the particles.\nThe units of the parameters are defined in [units].\nTo support simulation methods that uses several forcefields simultaneously, [[forcefields]] is defined as an array of tables. But normally, we need only one forcefield per simulation.\nenv #  In [[forcefields]] tables, a special field, env, can be used.\nBy defining a variable under the env table, you can name the value. Named values can be referenced via its name in the parameter section.\n[[forcefields.local]] env.pi = 3.1416 # this substitutes `3.1416` to `\u0026#34;pi\u0026#34;` parameters = [  {indices = [0, 1], k = 100.0, v0 = \u0026#34;pi\u0026#34;},  {indices = [1, 2], k = 100.0, v0 = \u0026#34;pi\u0026#34;},  {indices = [2, 3], k = 100.0, v0 = \u0026#34;pi\u0026#34;}, ] This feature can be used with file inclusion feature.\nLocalForceFiled #  A set of interactions that is applied to a specific set of particles. E.g. bond length, bond angle, or dihedral angle interaction.\nGlobalForceFiled #  A set of interactions that is applied to all the possible pair of particles. E.g. electrostatic, or Lennard-Jones interaction.\nExternalForceFiled #  A set of interactions that is applied to particles from external environment. E.g. restraint on a specific position, or a box interaction.\nConstraintForceField #  A set of constraints. Since it affects on the topology, it is defined as a forcefield.\nMultipleBasinForceField #  A special meta-forcefield that allows to concatenate two or more forcefields smoothly.\nHybridForceField #  A meta-forcefield that is a linear combination of two different forcefields.\n"}),e.add({id:13,href:"/Mjolnir/docs/reference/integrators/BAOABLangevinIntegrator/",title:"BAOABLangevin",section:"Integrators",content:"BAOABLangevin #  BAOABLangevin integrator performs constant temperature simulation according to Langevin equation.\nThis method is developed in the following paper.\n Benedict Leimkuhler and Charles Matthews. Appl. Math. Res. Exp. (2013) 2013:1, pp. 34-56 Benedict Leimkuhler and Charles Matthews. J. Chem. Phys. (2013) 138:17, 174102  Example #  [simulator] # ... integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  {index = 0, gamma = 1.0},  {index = 1, gamma = 1.0},  # ... ] Input reference #  Some of the other parameters, such as delta_t, are defined in [simulator] table.\n type: String  Name of the integrator. Here, it is \u0026quot;BAOABLangevin\u0026quot;.   gammas: Array of Tables     \\(\\gamma_i\\)  of the particles.   remove: Table (Optional)  translation and rotation: Boolean  If true, it removes the total translation and rotation. Otherwise, it does nothing.   rescale: Boolean  If true, it rescales all the velocities to make kinetic energy constant.   By default, all the fields becomes false.    "}),e.add({id:14,href:"/Mjolnir/docs/reference/forcefields/local/",title:"Local",section:"ForceFields",content:"LocalForceField #  LocalForceField contains a set of interactions that affects specific particles.\nBondLengthInteraction #  It depends on the distance between two particles.\nBondAngleInteraction #  It depends on the angle formed by 3 particles.\nDihedralAngleInteraction #  It depends on the angle formed by 2 planes, where each plane is defined by 3 particles.\nContactInteraction #  It depends on the distance between two particles.\nBasically it is the same as BondLength. But it consider the case when two particles are too distant and exceeds the cutoff range.\nDummyInteraction #  It does not do anything. It is used to define topology without applying force.\nSee Topology for detail.\n3SPN2BaseStacking #  It is specific to 3SPN2 Coarse-Grained DNA model.\n"}),e.add({id:15,href:"/Mjolnir/docs/reference/simulators/MolecularDynamicsSimulator/",title:"MolecularDynamics",section:"Simulators",content:"MolecularDynamics #  It performs a normal molecular dynamics simulation.\nIt takes one system and one forcefield to run the simulation.\nExample #  [simulator] type = \u0026#34;MolecularDynamics\u0026#34; boundary_type = \u0026#34;PeriodicCuboid\u0026#34; precision = \u0026#34;double\u0026#34; parallelism = \u0026#34;OpenMP\u0026#34; # optional seed = 12345 delta_t = 0.1 total_step = 50_000 save_step = 100 integrator.type = \u0026#34;VelocityVerlet\u0026#34; Input Reference #   type: String  To use MolecularDynamicsSimulator, set \u0026quot;MolecularDynamics\u0026quot;.   boundary_type: String  Type of the boundary condition. The size will be specified in [[systems]]. \u0026quot;Unlimited\u0026quot;: No boundary condition will applied. \u0026quot;Periodic\u0026quot;: Periodic boundary condition will be applied. The shape is recutangular box.   precision: String  Precision of floating point number used in the simulation. \u0026quot;float\u0026quot;: 32bit floating point number. \u0026quot;double\u0026quot;: 64bit floating point number.   parallelism: String (Optional. By default, \u0026quot;sequencial\u0026quot;.)  \u0026quot;OpenMP\u0026quot;: OpenMP implementation will be used. \u0026quot;sequencial\u0026quot;: Simulation runs on single core.   seed: Integer  Random number generator will be initialized by this value.   delta_t: Floating  Time step of the simulation. The unit depends on the unit system defined in [units]   total_step: Integer  Total time step of the simulation.   save_step: Integer  The state of the system will be saved at this interval.   integrator: Table  The time integration method to be used. \u0026ldquo;BAOABLangevin\u0026rdquo; \u0026ldquo;g-BAOABLangevin\u0026rdquo; \u0026ldquo;UnderdampedLangevin\u0026rdquo; \u0026ldquo;VelocityVerlet\u0026rdquo; For detail, see integrators.    "}),e.add({id:16,href:"/Mjolnir/docs/reference/integrators/gBAOABLangevinIntegrator/",title:"g-BAOABLangevin",section:"Integrators",content:"g-BAOABLangevin #  g-BAOABLangevin integrator performs constant temperature simulation according to Langevin equation.\nUnlike BAOABLangevin, it handles bond length constraints appropreately.\ng-BAOABLangevin is developed in the following paper.\n Leimkuhler B, Matthews C. Proc. R. Soc. A. (2016) 472: 20160138  Example #  [simulator] integrator.type = \u0026#34;g-BAOABLangevin\u0026#34; integrator.gammas = [  {index = 0, gamma = 1.0},  {index = 1, gamma = 1.0},  # ... ] Input reference #  Some of the other parameters, such as delta_t, are defined in [simulator] table.\n type: String  Name of the integrator. Here, it is \u0026quot;g-BAOABLangevin\u0026quot;.   gammas: Array of Tables     \\(\\gamma_i\\)  of the particles.   remove: Table (optional)  translation and rotation: Boolean  If true, it removes the total translation and rotation. Otherwise, it does nothing.   rescale: Boolean  If true, it rescales all the velocities to make kinetic energy constant.   By default, all the fields becomes false.    Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:17,href:"/Mjolnir/docs/reference/forcefields/global/",title:"Global",section:"ForceFields",content:"GlobalForceField #  GlobalForceField constins a set of interactions that affects all the particles.\nGlobalPair #  It depends on the distances between two particles.\n3SPN2BaseBase #  It is specific to 3SPN2 Coarse-Grained DNA model.\nProteinDNANonSpecific #  It is a Coarse-Grained hydrogen bond model.\nCommon parts #  There are common fields in [[forcefields.global]] table. One specifies the condition when an interaction is ignored. Another specifies the spatial partitioning method.\nignore #  There are 3 ways to define ignoring pairs.\nFirst, particles_within ignores pairs that are connected within N consecutive topological connection.\nSecond, group ignores inter- or intra-group particle pairs. group is defined in System.\nThird, molecule ignores inter- or intra-molecule particle pairs. molecule is defined as a set of particles that are connected to each other via bond topology. That means that, molecule is a connected component of a graph when we consider a particle as a node and a bond connection as an edge.\nTo define connections on the topology, see Topology.\n ignore.particles_within: Table  It ignores pairs of particles that are connected via a certain connection within a certain number. The key is the name of the connection, and the value is the number of concecutive connections. For example, ignore.particles_within.bond = 3 ignores particles that are connected via 1, 2, or 3 consecutive bond connections.   ignore.group: Table  It ignores inter- or intra-group pairs. intra: Array of Strings  It ignores intra-group particle pairs.   inter: Array of Array of Strings  It ignores inter-group particle pairs.   An example later follows.   ignore.molecule: String  It ignores inter-/intra-molecule pairs. \u0026quot;Nothing\u0026quot;: It does not ignore anything based on molecule (default). \u0026quot;Self\u0026quot;: It ignores intra-molecule pairs. \u0026quot;Others\u0026quot;: It ignores inter-molecule pairs.    Let\u0026rsquo;s say we have the following system.\n[[systems]] particles = [  {... group = \u0026#34;A\u0026#34;}, # particle 0  {... group = \u0026#34;A\u0026#34;}, # 1  {... group = \u0026#34;A\u0026#34;}, # 2   {... group = \u0026#34;B\u0026#34;}, # particle 3  {... group = \u0026#34;B\u0026#34;}, # 4  {... group = \u0026#34;B\u0026#34;}, # 5   {... group = \u0026#34;C\u0026#34;}, # particle 6  {... group = \u0026#34;C\u0026#34;}, # 7  {... group = \u0026#34;C\u0026#34;}, # 8 ] The following interaction\n[[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; ignore.group.intra = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] ignores interactions between 0-1, 0-2, 1-2, but does not ignore 0-3, 0-6, 3-6 interactions.\nAlso, the following interaction\n[[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; ignore.group.inter = [[\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;], [\u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;]] ignores interactions between 0-3, 0-4, 0-5, 3-6, 3-7, 3-8, but does not ignore 0-1, 3-4, 3-6 interactions.\nspatial_partition #  It provides spatial partitioning algorithm to construct a neighbor list.\n type: String  The following spatial partitioning methods are available. \u0026quot;CellList\u0026quot; \u0026quot;RTree\u0026quot; \u0026quot;VerletList\u0026quot;   margin: Floating  The margin in the neighboring list, relative to the cutoff length. It affects the efficiency, but not the accuracy. The most efficient value depends on a potential to be used.    "}),e.add({id:18,href:"/Mjolnir/docs/reference/simulators/SimulatedAnnealingSimulator/",title:"SimulatedAnnealing",section:"Simulators",content:"SimulatedAnnealing #  It runs simulated annealing simulation.\nIt takes one system and one forcefield to run the simulation.\nExample #  [simulator] type = \u0026#34;SimulatedAnnealing\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; parallelism = \u0026#34;OpenMP\u0026#34; # optional delta_t = 0.1 total_step = 50_000 save_step = 100 each_step = 100 schedule.type = \u0026#34;linear\u0026#34; schedule.begin = 300.0 # temperature in [K] schedule.end = 150.0 # temperature in [K]  integrator.type = \u0026#34;UnderdampedLangevin\u0026#34; integrator.parameters = [  # ... ] Input Reference #   type: String  Name of the simulator. Here, it is \u0026quot;SimulatedAnnealing\u0026quot;.   boundary_type: String  Type of the boundary condition. The size will be specified in [[systems]]. \u0026quot;Unlimited\u0026quot;: No boundary condition will applied. \u0026quot;Periodic\u0026quot;: Periodic boundary condition will be applied. The shape is recutangular box.   precision: String  Precision of floating point number used in the simulation. \u0026quot;float\u0026quot;: 32bit floating point number. \u0026quot;double\u0026quot;: 64bit floating point number.   parallelism: String (Optional. By default, \u0026quot;sequencial\u0026quot;.)  \u0026quot;OpenMP\u0026quot;: OpenMP implementation will be used. \u0026quot;sequencial\u0026quot;: Simulation runs on single core.   seed: Integer  Random number generator will be initialized by this value.   delta_t: Floating  Time step of the simulation. The unit depends on the unit system defined in [units]   total_step: Integer  Total time step of the simulation.   save_step: Integer  The state of the system will be saved at this interval.   each_step: Integer  The temperature of the system will be updated at this interval.   schedule: Table  The schedule for temperature control. See below.   integrator: Table  The time integration method to be used. \u0026ldquo;BAOABLangevin\u0026rdquo; \u0026ldquo;g-BAOABLangevin\u0026rdquo; \u0026ldquo;UnderdampedLangevin\u0026rdquo; For detail, see integrators.    schedule Table #   type: String  Type of the control curve. Available curves are below. \u0026quot;linear\u0026quot;   begin: Floating  The temperature at the first frame. The unit is [K].   end: Floating  The temperature at the last frame. The unit is [K].    "}),e.add({id:19,href:"/Mjolnir/docs/reference/forcefields/external/",title:"External",section:"ForceFields",content:"ExternalForceField #  ExternalForceField contains a set of interactions between particle and an external field.\nPositionRestraintInteraction #  It restrains a particle at a fixed point.\nIt also can restrain a particle at a fixed distance from a certain point.\nPullingForceInteraction #  It applies a force to the specified particle.\nCoMPullingForceInteraction #  It applies a force to the center of mass of the specified particles.\nRectangularBoxInteraction #  It wraps the system by a rectangular box. It does not work under the periodic boundary condition.\nExternalDistanceInteraction #  It depends on the distance between particles and a structure such as a planner surface.\nAFMFittingInteraction #  It depends on the correlation coefficient between pseudo AFM image and the reference image.\nIt is capable of fitting a biomolecular model to an experimental AFM image.\n"}),e.add({id:20,href:"/Mjolnir/docs/reference/integrators/G-JFLangevinIntegrator/",title:"G-JFLangevin",section:"Integrators",content:"G-JFLangevin #  G-JFLangevin integrator performs constant temperature simulation according to Langevin equation.\n  \\[\\begin{aligned} m\\frac{d^2 \\bold{r}}{dt^2} \u0026amp;= \\bold{f}(\\bold{r}) - \\alpha\\bold{v} \u0026#43; \\beta(t) \\\\ \\langle\\beta(t)\\rangle \u0026amp;= 0 \\\\ \\langle\\beta(t)\\beta(t\u0026#39;)\\rangle \u0026amp;= 2\\alpha k_B T \\delta(t - t\u0026#39;) \\end{aligned}\\]  This method is developed in the following paper.\n Niels Grønbech-Jensen \u0026amp; Oded Farago, (2013) Mol.Phys. 111:8, 983-991  Example #  [simulator] # ... integrator.type = \u0026#34;G-JFLangevin\u0026#34; integrator.alphas = [  {index = 0, alpha = 1.0},  {index = 1, alpha = 1.0},  # ... ] Input reference #  Some of the other parameters, such as delta_t, are defined in [simulator] table.\n type: String  Name of the integrator. Here, it is \u0026quot;G-JFLangevin\u0026quot;.   alphas: Array of Tables   \\(\\alpha\\)  of each particle.   remove: Table (Optional)  translation and rotation: Boolean  If true, it removes the total translation and rotation. Otherwise, it does nothing.   rescale: Boolean  If true, it rescales all the velocities to make kinetic energy constant.   By default, all the fields becomes false.    "}),e.add({id:21,href:"/Mjolnir/docs/reference/simulators/SteepestDescentSimulator/",title:"SteepestDescent",section:"Simulators",content:"SteepestDescent #  It performs steepest descent (gradient descent) method.\nIt takes one system and one forcefield to run the simulation.\nExample #  [simulator] type = \u0026#34;SteepestDescent\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; delta = 1e-4 threshold = 1e-4 step_limit = 1_000_000 save_step = 100 Input Reference #   type: String  To use MolecularDynamicsSimulator, set \u0026quot;SteepestDescent\u0026quot;.   boundary_type: String  Type of the boundary condition. The size will be specified in [[systems]]. \u0026quot;Unlimited\u0026quot;: No boundary condition will applied. \u0026quot;Periodic\u0026quot;: Periodic boundary condition will be applied. The shape is recutangular box.   precision: String  Precision of floating point number used in the simulation. \u0026quot;float\u0026quot;: 32bit floating point number. \u0026quot;double\u0026quot;: 64bit floating point number.   parallelism: String (Optional. By default, \u0026quot;sequencial\u0026quot;.)  \u0026quot;OpenMP\u0026quot;: OpenMP implementation will be used. \u0026quot;sequencial\u0026quot;: Simulation runs on single core.   delta: Floating  The coefficient of particle movement relative to the force.   threshold: Floating  If the maximum displacement of the particles is less than this threshold, it stops the simulation.   step_limit: Integer  The limit of total number of steps. It stops if the total number of steps would reach to this limit regardless of the convergence.   save_step: Integer  The state of the system will be saved at this interval. The last snapshot will be saved regardless of this number.    "}),e.add({id:22,href:"/Mjolnir/docs/reference/forcefields/constraint/",title:"Constraint",section:"ForceFields",content:"ConstraintForceField #  ConstraintForceField is a set of consraints on a distance between two particles.\nCurrently, only g-BAOABLangevin integrator can handle this.\nExample #  [[forcefields.constraint]] topology = \u0026#34;bond\u0026#34; max_iteration = 500 tolerance = 1e-6 parameters = [  {indices = [0, 1], offset = 100, v0 = 3.8},  # ... ] Input Reference #   topology: String  Name of this constraint on \u0026quot;Topology\u0026quot;   max_iteration: Integer  It repeats the correction up to this number of times until convergence. If it does not converge, a warning will be shown. In most cases, it will diverge.   tolerance: Floating  Tolerance to be used in convergence check.   parameters: Array of Tables  indices: Array of Integers (length = 2)  The index of particles to be constrained. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offsets of index.   v0: Floating  The reference distance between particles.      Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:23,href:"/Mjolnir/docs/reference/integrators/GFWNPTLangevinIntegrator/",title:"GFWNPTLangevin",section:"Integrators",content:"GFWNPTLangevin #  GFWNPTLangevin integrator performs constant temperature and constant pressure simulation according to Langevin equation.\nThis method is introduced in the following paper.\n Xingyu Gao, Jun Fang, and Han Wang. J. Chem. Phys. (2016) 144, 124113  Example #  [simulator] # ... integrator.type = \u0026#34;GFWNPTLangevin\u0026#34; integrator.chi = 0.0 integrator.cell_mass = [1e3, 1e3, 1e3] integrator.cell_gamma = [0.1, 0.1, 0.1] integrator.gammas = [  {index = 0, gamma = 0.1},  {index = 1, gamma = 0.1},  # ... ] Input reference #  Some of the other parameters, such as delta_t, are defined in [simulator] table.\n type: String  Name of the integrator. Here, it is \u0026quot;GFWNPTLangevin\u0026quot;.   chi: Floating     \\( chi \\)  value introduced in the paper.   cell_mass: Array of Floating numbers  virtual mass of the box in each direction.   cell_gamma: Array of Floating numbers  friction coefficient of the cell.   gammas: Array of Tables   \\(\\gamma_i\\)  of the particles.   remove: Table (Optional)  translation and rotation: Boolean  If true, it removes the total translation and rotation. Otherwise, it does nothing.   rescale: Boolean  If true, it rescales all the velocities to make kinetic energy constant.   By default, all the fields becomes false.    "}),e.add({id:24,href:"/Mjolnir/docs/reference/simulators/SwitchingForceFieldSimulator/",title:"SwitchingForceField",section:"Simulators",content:"SwitchingForceField #  It performs molecular dynamics simulation and changes forcefields at the given frame.\nIt takes one system and several forcefields to run the simulation.\nExample #  [simulator] type = \u0026#34;SwitchingForceField\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; delta_t = 0.1 total_step = 3_000_000 save_step = 100 seed = 2374  integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.parameters = [ {index = 0, gamma = 1.00}, {index = 1, gamma = 1.00}, ]  schedule = [  {until = 1_000_000, forcefield = \u0026#34;close\u0026#34;},  {until = 2_000_000, forcefield = \u0026#34;open\u0026#34;},  {until = 3_000_000, forcefield = \u0026#34;close\u0026#34;}, ]  [[forcefields]] name = \u0026#34;close\u0026#34; [[forcefields.local]] # ...  [[forcefields]] name = \u0026#34;open\u0026#34; [[forcefields.local]] # ... Input Reference #   type: String  Name of the simulator. Here, it is \u0026quot;SwitchingForceField\u0026quot;.   boundary_type: String  Type of the boundary condition. The size will be specified in [[systems]]. \u0026quot;Unlimited\u0026quot;: No boundary condition will applied. \u0026quot;Periodic\u0026quot;: Periodic boundary condition will be applied. The shape is recutangular box.   precision: String  Precision of floating point number used in the simulation. \u0026quot;float\u0026quot;: 32bit floating point number. \u0026quot;double\u0026quot;: 64bit floating point number.   parallelism: String (Optional. By default, \u0026quot;sequencial\u0026quot;.)  \u0026quot;OpenMP\u0026quot;: OpenMP implementation will be used. \u0026quot;sequencial\u0026quot;: Simulation runs on single core.   seed: Integer  Random number generator will be initialized by this value.   delta_t: Floating  Time step of the simulation. The unit depends on the unit system defined in [units]   total_step: Integer  Total time step of the simulation.   save_step: Integer  The state of the system will be saved at this interval.   integrator: Table  The time integration method to be used. \u0026ldquo;BAOABLangevin\u0026rdquo; \u0026ldquo;g-BAOABLangevin\u0026rdquo; \u0026ldquo;UnderdampedLangevin\u0026rdquo; \u0026ldquo;VelocityVerlet\u0026rdquo; For detail, see integrators.   schedule: Array of Tables  The schedule for forcefield control. See below.    schedule #  schedule is an array of tables and each table has the following fields.\n until: Integer  It uses the specified forcefield until this frame.   forcefield: String  Name of the forcefield.    schedule = [  {until = 1_000_000, forcefield = \u0026#34;close\u0026#34;},  {until = 2_000_000, forcefield = \u0026#34;open\u0026#34;},  {until = 3_000_000, forcefield = \u0026#34;close\u0026#34;}, ] The name of the forcefield is defined via name under [[forcefields]].\n[[forcefields]] name = \u0026#34;close\u0026#34;  [[forcefields.local]] # This is a component of \u0026#34;close\u0026#34; forcefield. interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; # ...  [[forcefields.local]] # This is a component of \u0026#34;close\u0026#34; forcefield. interaction = \u0026#34;BondAngle\u0026#34; potential = \u0026#34;Harmonic\u0026#34; # ...  [[forcefields]] name = \u0026#34;open\u0026#34;  [[forcefields.local]] # This is a component of \u0026#34;open\u0026#34; forcefield. # ... "}),e.add({id:25,href:"/Mjolnir/docs/reference/simulators/EnergyCalculationSimulator/",title:"EnergyCalculation",section:"Simulators",content:"EnergyCalculation #  It does not perform any simulation.\nIt calculates energy of each snapshot written in a given trajectory file, taking one ForceField.\nIt does not use any Integrator. Also, coordinates specified in [[systems]] will be overwritten by the trajectory file.\nStill, it requires [[systems]] field because group of the particle is given in [[systems]].\nExample #  [simulator] type = \u0026#34;EnergyCalculation\u0026#34; boundary_type = \u0026#34;PeriodicCuboid\u0026#34; precision = \u0026#34;double\u0026#34; parallelism = \u0026#34;OpenMP\u0026#34; # optional file = \u0026#34;example_position.dcd\u0026#34; Input Reference #   type: String  Name of the simulator. Here, it is \u0026quot;EnergyCalculation\u0026quot;.   boundary_type: String  Type of the boundary condition. The size will be specified in [[systems]]. \u0026quot;Unlimited\u0026quot;: No boundary condition will applied. \u0026quot;Periodic\u0026quot;: Periodic boundary condition will be applied. The shape is recutangular box.   precision: String  Precision of floating point number used in the simulation. \u0026quot;float\u0026quot;: 32bit floating point number. \u0026quot;double\u0026quot;: 64bit floating point number.   parallelism: String (Optional. By default, \u0026quot;sequencial\u0026quot;.)  \u0026quot;OpenMP\u0026quot;: OpenMP implementation will be used. \u0026quot;sequencial\u0026quot;: It runs on single core.   file: String  Trajectory file. It considers the input path specified in [files].    "}),e.add({id:26,href:"/Mjolnir/docs/reference/forcefields/MultipleBasinForceField/",title:"MultipleBasin",section:"ForceFields",content:"MultipleBasinForceField #  MultipleBasinForceField connects different forcefields and makes it possible to change states between those two forcefields smoothly.\nIt is developed in the following paper as a method that enables conformational changes with Coarse-Grained model by employing multiple off-lattice Go potentials.\n Kei-ichi Okazaki, Nobuyasu Koga, Shoji Takada, Jose N. Onuchic, and Peter G. Wolynes PNAS (2006)  Mjolnir implements this as a generalized form, and we can use any forcefields as a \u0026ldquo;Basin\u0026rdquo; in a Multiple Basin forcefield.\nIn this model, the potential function   \\( V_{MB} \\)  is defined as a minimum eigenvalue of the matrix that appears at the left hand side of the following equation.\n \\[\\begin{pmatrix} V_1 \u0026#43; \\Delta V_1 \u0026amp; \\Delta \\\\ \\Delta \u0026amp; V_2 \u0026#43; \\Delta V_2 \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} = V_{MB} \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix}\\]  The elements of the eigenvalue,  \\( c_1 \\)  and  \\( c_2 \\)  , can be interpreted as a density of the corresponding states.\nAs a reaction coordinate, the following value will be printed along with the energy values.\n \\[\\chi = \\log\\left(\\frac{c_2}{c_1}\\right)\\]  Note that this value will becomes NaN in the case of  \\( 0 \u0026lt; \\Delta \\)  . To avoid this, Mjolnir makes  \\(\\Delta\\)  always negative.  \\( V_{MB} \\)  depends on  \\( \\Delta^2 \\)  , so only the absolute value of  \\( \\Delta \\)  matters.\nIn case of 2-basin unit, you can restrain  \\( \\chi \\)  by using harmonic potential.\n \\[V_{Bias} = k (\\chi - \\chi_0)^2\\]  You can perform umbrella sampling along the reaction coordinate,  \\( \\chi \\)  . This will help you when you need to determine the value of  \\( \\Delta \\)  and  \\( \\Delta V \\)  .\n The 3-basin case is also defined in a similar way.\n \\[\\begin{pmatrix} V_1 \u0026#43; \\Delta V_1 \u0026amp; \\Delta_{12} \u0026amp; \\Delta_{13} \\\\ \\Delta_{21} \u0026amp; V_2 \u0026#43; \\Delta V_2 \u0026amp; \\Delta_{23} \\\\ \\Delta_{31} \u0026amp; \\Delta_{32} \u0026amp; V_3 \u0026#43; \\Delta V_3 \\\\ \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_2 \\\\ c_3 \\end{pmatrix} = V_{MB} \\begin{pmatrix} c_1 \\\\ c_2 \\\\ c_3 \\end{pmatrix}\\]  Here,  \\(\\Delta_{ij} = \\Delta_{ji}\\)  .\nCurrently, Mjolnir only supports 2 or 3 forcefields in MultipleBasin.\nNote that all the forcefields should have the same topology.\nExample input #  First, you need to define and name several forcefields to be connected. Note that a forcefield named as \u0026quot;common\u0026quot; will always be applied independent from MultipleBasin forcefield.\nThen, set forcefields.type = \u0026quot;MultipleBasin\u0026quot; in [simulator] table and provide parameters for MultipleBasin.\nMjolnir allows to define several MultipleBasin units. This feature would be helpful in a case when you have several proteins that undergoes conformational changed independently from each other.\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; delta_t = 0.1 total_step = 1000000 save_step = 1_000 seed = 2859805901 integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  # ... ] forcefields.type = \u0026#34;MultipleBasin\u0026#34; forcefields.units = [ {basins = [\u0026#34;open\u0026#34;, \u0026#34;close\u0026#34;], dVs = [0.0, -12.0], delta = 150.0}, ] # # Or, the following has the same meaning. #  # [simulator.forcefields] # type = \u0026#34;MultipleBasin\u0026#34; # [[simulator.forcefields.units]] # basins = [\u0026#34;open\u0026#34;, \u0026#34;close\u0026#34;], # dVs = [0.0, -12.0], # delta = 150.0,  [[forcefields]] name = \u0026#34;open\u0026#34; [[forcefields.local]] # ...  [[forcefields]] name = \u0026#34;close\u0026#34; [[forcefields.local]] # ...  [[forcefields]] name = \u0026#34;common\u0026#34; [[forcefields.local]] # ... To restrain  \\( \\chi \\)  , define k_chi and chi_0.\nforcefields.type = \u0026#34;MultipleBasin\u0026#34; forcefields.units = [ {basins = [\u0026#34;open\u0026#34;, \u0026#34;close\u0026#34;], dVs = [0.0, -12.0], delta = 150.0, k_chi = 100.0, chi_0 = 0.0}, ] To use 3-basin model, do the following.\n[simulator.forcefields] type = \u0026#34;MultipleBasin\u0026#34; [[simulator.forcefields.units]] basins = [\u0026#34;open\u0026#34;, \u0026#34;mid\u0026#34;, \u0026#34;close\u0026#34;] dVs = [ 0.0, 15.0, -10.0] delta.open-mid = 60.0 # concatenate basin name by `-`. delta.mid-close = 50.0 # do not include `-` in basin names to avoid confusion. delta.close-open = 100.0 Note for AICG2+ forcefields #  When AICG2+ is used with MultipleBasin, you may need to modify AICG2+ parameters slightly. In such a case, we will have several reference structures for the same protein. The native bond lengthes, bond angles, dihedral angles, and native contact distances could be different between reference structures and some of the native contacts could be defined only in one reference structure.\nBond length parameter #  When two native bond lengthes that correspond to the same pair of particles are too distant, the force coefficient will be moderated to decrease energy value at the transition state.\n \\[K\u0026#39;_{bond} = K_{bond} \\times \\mathrm{min}\\left(1, \\frac{E_{max}}{K_b(b_i^{(1)} - b_i^{(2)})^2}\\right)\\]  Normally, people use 100 kcal/mol as  \\( E_{max} \\)  .\nNative contact parameter #  The modification on native contacts are complicated.\nThere are 3 different cases.\n The pair of particles has native contact in all the reference structures. In one reference structure, the pair forms a native contact, but not in another. No contact is defined in any of the reference structures.  In the case of 1., the repulsive part of the native contacts will be modified. Always the minimum native distance is used as the native distance of the repulsive part, while the attractive part is unchanged.\nIn the case of 2., the forcefield that has the native contact is unchanged. But for the forcefield that does not have the native contact will have the repulsive part of the contact.\nIn the last case, 3., the same excluded volume interaction will be applied.\n"}),e.add({id:27,href:"/Mjolnir/docs/reference/integrators/UnderdampedLangevinIntegrator/",title:"UnderdampedLangevin",section:"Integrators",content:"UnderdampedLangevin #  UnderdampedLangevin integrator performs constant temperature simulation according to Langevin equation.\nThis method is developed in the following paper.\n J. D. Honeycutt and D. Thirumalai, (1992) Biopolymers Z. Guo and D. Thirumalai, (1995) Biopolymers.  It is the same method that is employed in CafeMol.\nExample #  [simulator] # ... integrator.type = \u0026#34;UnderdampedLangevin\u0026#34; integrator.gammas = [  {index = 0, gamma = 1.0},  {index = 1, gamma = 1.0},  # ... ] Input reference #  Some of the other parameters, such as delta_t, are defined in [Simulator] table.\n type: String  The name of Integrator. Here, it is \u0026quot;UnderdampedLangevin\u0026quot;.   gammas: Array of Tables     \\(\\gamma_i\\)  of the particles.   remove: Table (Optional)  translation and rotation: Boolean  If true, it removes the total translation and rotation. Otherwise, it does nothing.   rescale: Boolean  If true, it rescales all the velocities to make kinetic energy constant.   By default, all the fields becomes false.    "}),e.add({id:28,href:"/Mjolnir/docs/reference/forcefields/HybridForceField/",title:"HybridForceField",section:"ForceFields",content:"HybridForceField #  HybridForceField connects two different forcefields.\n  \\[V = \\lambda V_1 \u0026#43; (1 - \\lambda) V_2\\]  The topology can be different.\nExample input #  First, you need to define and name several forcefields to be connected.\nThen, set forcefields.type = \u0026quot;Hybrid\u0026quot; in [simulator] table and provide lambda value. The first and the second [[forcefields]] table will be the  \\( V_1 \\)  and  \\( V_2 \\)  in the above equation, respectively.\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; delta_t = 0.1 total_step = 1000000 save_step = 1_000 seed = 2859805901 integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  # ... ] forcefields.type = \u0026#34;Hybrid\u0026#34; forcefields.lambda = 0.5 # ...  [[forcefields]] # V1 [[forcefields.local]] # ...  [[forcefields]] # V2 [[forcefields.local]] # ... make λ dynamic #  We can integrate  \\(\\lambda\\)  over time by considering it as a dynamic variable. To do that, set forcefields.lambda = \u0026quot;dynamic\u0026quot; and define dynamic_variables.lambda in [[systems]]. The coordinate, velocity, force are saved in the .ene file.\nAlso, you can apply a harmonic potential  \\(k(\\lambda - \\lambda_0)^2\\)  to  \\(\\lambda\\)  .\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; delta_t = 0.1 total_step = 1000000 save_step = 1_000 seed = 2859805901 integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  # ... ] forcefields.type = \u0026#34;Hybrid\u0026#34; forcefields.lambda = \u0026#34;dynamic\u0026#34; # make lambda dynamic forcefields.v0_lambda = 1.0 # k(v - v0)^2 forcefields.k_lambda = 100.0 # k(v - v0)^2  # ...  [[systems]] attributes.temperature = 300.0 dynamic_variables.lambda = {x = 1.0, m = 1000.0, gamma = 1e-5, boundary = \u0026#34;Repulsive\u0026#34;, lower = 0.0, upper = 1.0}  [[forcefields]] # V1 [[forcefields.local]] # ...  [[forcefields]] # V2 [[forcefields.local]] # ... "}),e.add({id:29,href:"/Mjolnir/docs/reference/forcefields/Topology/",title:"Topology",section:"ForceFields",content:"Topology #  In some cases, LocalForceField affects GlobalForceField. For example, excluded volume interaction would not be applied to a pair of particles that interact with each other via bond length interaction.\nTo share the information among forcefields, Topology is constructed.\nIt contains graph structure where particles are represented as nodes and local interactions are represented as edges.\nLocalForceField can name the interaction. GlobalForceField can ignore specific local interactions.\n[[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], ... },  # ... ]  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;ExcludedVolume\u0026#34; ignore.particles_within.bond = 3 # ignore particles within 3 bonds. ignore.particles_within.contact = 1 # ignore particles within 1 contact. # ... parameters = [  # ... ] "}),e.add({id:30,href:"/Mjolnir/docs/reference/integrators/VelocityVerletIntegrator/",title:"VelocityVerlet",section:"Integrators",content:"VelocityVerlet #  VelocityVerlet integrator performs constant energy simulation according to Newtonian dynamics.\nExample #  [simulator] integrator.type = \u0026#34;VelocityVerlet\u0026#34; integrator.remove.translation = true integrator.remove.rotation = true integrator.remove.rescale = true Input reference #  Some of the other parameters, such as delta_t, are defined in [simulator] table.\n type: String  The name of Integrator. Here, it is \u0026quot;VelocityVerlet\u0026quot;.   remove: Table (optional)  translation and rotation: Boolean  If true, it removes the total translation and rotation. Otherwise, it does nothing.   rescale: Boolean  If true, it rescales all the velocities to make kinetic energy constant.   By default, all the fields becomes false.    "}),e.add({id:31,href:"/Mjolnir/docs/reference/forcefields/local/bondlength/",title:"BondLength",section:"Local",content:"BondLengthInteraction #  BondLengthInteraction is an interaction that depends on the distance between particles.\nThe following potentials are available.\n Harmonic Gaussian GoContact AttractiveGoContact RepulsiveGoContact WormLikeChain WormLikeChainOffset 3SPN2Bond  Example #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  # required parameters depend on a potential...  {indices = [0, 1], offset = 100, ... }, ] Input Reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;BondLength\u0026quot;.   potential: String  The following potentials are available. Harmonic Gaussian GoContact AttractiveGoContact RepulsiveGoContact WormLikeChain 3SPN2Bond   topology: String  Name of the connection in Topology.   parameters: Array of Tables  indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.   The other parameter depends on the specified potential.    "}),e.add({id:32,href:"/Mjolnir/docs/reference/forcefields/global/pair/",title:"Pair",section:"Global",content:"GlobalPair #  GlobalPairInteraction will be applied to all the possible pairs of particles participating in the interaction.\nThe following potentials are available.\n LennardJones UniformLennardJones DebyeHuckel ExcludedVolume InversePower HardCoreExcludedVolume WCAPotential iSoLFAttractive 3SPN2ExcludedVolume  Example #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;ExcludedVolume\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 ignore.groups.intra = [\u0026#34;chain-A\u0026#34;] ignore.groups.inter = [[\u0026#34;chain-B\u0026#34;, \u0026#34;chain-C\u0026#34;]] spatial_partition.type = \u0026#34;CellList\u0026#34; spatial_partition.margin = 0.2 parameters = [  {index = 0, offset = 100, ...}, # required parameter depends on the potential.  # ... ] Input Reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;Pair\u0026quot;.   potential: String  The following potentials are available. \u0026quot;LennardJones\u0026quot; \u0026quot;UniformLennardJones\u0026quot; \u0026quot;DebyeHuckel\u0026quot; \u0026quot;ExcludedVolume\u0026quot; \u0026quot;InversePower\u0026quot; \u0026quot;HardCoreExcludedVolume\u0026quot; \u0026quot;WCA\u0026quot; \u0026quot;iSoLFAttractive\u0026quot;   ignore: Table  It describes the condition when the pair of particles does not interact to each other. For detail, see the ignore section of GlobalForceField   spatial_partition: Table  It specifies the algorithm to construct a neighbor list. For detail, see the ignore section of GlobalForceField   parameters: Array of Tables  index: Integer  The index of a particle. The index is 0-based.   offset: Integer (Optional. By default, 0.)  The offset value for the index.      "}),e.add({id:33,href:"/Mjolnir/docs/reference/forcefields/external/PositionRestraintInteraction/",title:"PositionRestraint",section:"External",content:"PositionRestraint #  It restrains a particle to a fixed point in a space via harmonic potential.\nExample #  [[forcefields.external]] interaction = \u0026#34;PositionRestraint\u0026#34; potential = \u0026#34;Harmonic\u0026#34; parameters = [  {index = 0, position = [0.0, 0.0, 0.0], k = 0.1, v0 = 10.0},  # ... ] Input Reference #   interaction: String  Name of the interaciton. Here, it is \u0026quot;PositionRestraint\u0026quot;.   potential: String  Name of the potential. Currently, only the harmonic potential is available.   parameters: Table  index: Integer  The index of the particle. The index is 0-based.   offset: Integer (Optional. By default, 0.)  The offset value for the index.   position: Array of Floatings  The cartesian coordinate (x, y, and z in this order) of the position.   k: Floating  The strength of the restraint.   v0: Floating  The native distance from the point. To restrain a particle exactly at the position, set 0.      "}),e.add({id:34,href:"/Mjolnir/docs/reference/forcefields/global/3SPN2BaseBaseInteraction/",title:"3SPN2Base",section:"Global",content:"3SPN2BaseBaseInteraction #  3SPN2BaseBaseInteraction is speicfic to the 3SPN2 Coarse-Grained DNA model.\nThe following potentials are available.\n \u0026quot;3SPN2\u0026quot;: Hinckley et al., (2013) JCP \u0026quot;3SPN2C\u0026quot;: Freeman et al., (2014) JCP  Example #  [[forcefields.global]] interaction = \u0026#34;3SPN2BaseBase\u0026#34; potential = \u0026#34;3SPN2\u0026#34; ignore.particles_within.nucleotide = 3 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2} parameters = [ # `nucleotide` index starts from 5\u0026#39; and ends at 3\u0026#39;. {strand = 0, nucleotide = 0, S = 0, B = 1, offset = 100, Base = \u0026#34;A\u0026#34;}, {strand = 0, nucleotide = 1, P = 2, S = 3, B = 4, offset = 100, Base = \u0026#34;T\u0026#34;}, {strand = 0, nucleotide = 2, P = 5, S = 6, B = 7, offset = 100, Base = \u0026#34;C\u0026#34;}, # ... ] Input Reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;3SPN2BaseBase\u0026quot;.   potential: String  The following potentials are available. 3SPN2 3SPN2C   ignore: Table  It describes the condition when the pair of particles does not interact to each other. Since 3SPN2 only allows base pairs between nucleotides that are at least 3 nucleotides distant. Set nucleotide = 3 and name 3SPN2BaseStacking.topology as nucleotide. For detail, see the ignore section of GlobalForceField   spatial_partition: Table  It specifies the algorithm to construct a neighbor list. For detail, see the ignore section of GlobalForceField   parameters: Array of Tables  strand: Integer  Index of the strand.   nucleotide: Integer  Index of the nucleotide.   P, S, B: Integer  Indices of particles that correspond to phosphate (P), sugar (S), and base (B). The index is 0-based.   offset: Integer (Optional. By default, 0.)  The offset value for the index.   Base: String  One of \u0026quot;A\u0026quot;, \u0026quot;T\u0026quot;, \u0026quot;C\u0026quot; or \u0026quot;G\u0026quot;.   Normally nucleotide at the edge of the DNA does not have phosphate.    "}),e.add({id:35,href:"/Mjolnir/docs/reference/forcefields/local/bondangle/",title:"BondAngle",section:"Local",content:"BondAngleInteraction #  BondAngleInteraction depends on the angle formed by 3 particles.\nThe following potentials are available.\n Harmonic Gaussian FlexibleLocalAngle  Example #  [[forcefields.local]] interaction = \u0026#34;BondAngle\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  # required parameters depend on a potential...  {indices = [0, 1, 2], offset = 100, ... }, ] Input Reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;BondLength\u0026quot;.   potential: String  The following potentials are available. Harmonic Gaussian FlexibleLocalAngle   topology: String  Name of the connection in Topology.   parameters: Array of Tables  indices: Array of Integers (length = 3)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.   The other parameter depends on the specified potential.    "}),e.add({id:36,href:"/Mjolnir/docs/reference/forcefields/external/rectangularbox/",title:"RectangularBox",section:"External",content:"RectangularBox #  RectangularBox interaction keeps particles inside a box.\nIf any particle locates outside of the box at the initial configuration, it fails to start.  This interaction does not work under the periodic boundary condition.  Example #  [[forcefields.external]] interaction = \u0026#34;RectangularBox\u0026#34; potential = \u0026#34;ExcludedVolumeWall\u0026#34;  box.lower = [ 0.0, 0.0, 0.0] box.upper = [100.0, 100.0, 100.0] box.margin = 0.4  # potential related epsilon = 0.1 parameters = [  {index = 0, radius = 1.0}, # required parameters depend on potential. ] Input reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;RectangularBox\u0026quot;.   potential: String  \u0026quot;LennardJonesWall\u0026quot; \u0026quot;ExcludedVolumeWall\u0026quot;   box: Table  box.lower: Array of Floats  lower boundary of the box.   box.upper: Array of Floats  upper boundary of the box.   box.margin: Float  margin of the neighboring list, relative to the cutoff length.      "}),e.add({id:37,href:"/Mjolnir/docs/reference/forcefields/local/dihedral/",title:"DihedralAngle",section:"Local",content:"DihedralAngleInteraction #  DihedralAngleInteraction depends on the angle formed by 2 planes, where each plane is defined by 3 particles.\nThe following potentials are available.\n Cosine Gaussian ClementiDihedral FlexibleLocalDihedral  Example #  [[forcefields.local]] interaction = \u0026#34;DihedralAngle\u0026#34; potential = \u0026#34;Cosine\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  # required parameters depend on a potential...  {indices = [0, 1, 2, 3], ... }, ] Input Reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;BondLength\u0026quot;.   potential: String  The following potentials are available. Cosine Gaussian ClementiDihedral FlexibleLocalDihedral   topology: String  Name of the connection in Topology.   parameters: Array of Tables  indices: Array of Integers (length = 3)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.   The other parameter depends on the specified potential.    Combination #  Some forcefields apply different potential functions to the same set of particles. Since dihedral angle calculation is costly operation relative to other local interactions, it is better to use those functions at once. The following frequently-used combination is supported.\n \u0026quot;Gaussian+FlexibleLocalDihedral\u0026quot; \u0026quot;Gaussian+Cosine\u0026quot;  Parameters of each potential is defined as an inline table, like: PotentialName = {}. For example,\n[[forcefields.local]] interaction = \u0026#34;DihedralAngle\u0026#34; potential = \u0026#34;Gaussian+FlexibleLocalDihedral\u0026#34; topology = \u0026#34;none\u0026#34; env.ALA-ALA = [2.2056, 0.2183, -0.0795, 0.0451, -0.3169, 0.0165, -0.1375] parameters = [ {indices = [0,1,2,3], Gaussian = {v0=-2.2, k=-0.43,sigma=0.15}, FlexibleLocalDihedral = {k=1.0, coef=\u0026#34;ALA-ALA\u0026#34;}}, # ... ] "}),e.add({id:38,href:"/Mjolnir/docs/reference/forcefields/external/distance/",title:"Distance",section:"External",content:"ExternalDistance #  It depends on the distance between particles and a structure such as a planner surface.\nExample #  [[forcefields.external]] interaction = \u0026#34;Distance\u0026#34; potential = \u0026#34;LennardJonesWall\u0026#34; shape.name = \u0026#34;AxisAlignedPlane\u0026#34; shape.axis = \u0026#34;X\u0026#34; shape.position = 0.0 shape.margin = 0.5 parameters = [ # ... ] Input Reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;Distance\u0026quot;.   potential: String  The following potentials are available. \u0026quot;LennardJonesWall\u0026quot; \u0026quot;ExcludedVolumeWall\u0026quot; \u0026quot;ImplicitMembrane\u0026quot;   shape: Table  The shape and the position of a structure that interacts with particles.    shape #   name: String  The following shape is available. \u0026quot;AxisAlignedPlane\u0026quot; requires the following fields.  axis: String  The axis that is parpendicular to the plane. like: \u0026quot;X\u0026quot;, \u0026quot;Y\u0026quot;, \u0026quot;Z\u0026quot;.   position: Floating  The position of the plane along the axis specified.       margin: Floating  The margin of the neighborling list relative to the cutoff length.    "}),e.add({id:39,href:"/Mjolnir/docs/reference/forcefields/global/ProteinDNANonSpecificInteraction/",title:"PDNS",section:"Global",content:"ProteinDNANonSpecificInteraction #  ProteinDNANonSpecificInteraction is a coarse-grained model of hydrogen bond, especially formed between protein and DNA.\nIt is developed in the following paper.\n T.Niina‡, G.B.Brandani‡, C.Tan and S.Takada, (2017) PLoS Comput Biol. (‡: co-1st)  Example #  [[forcefields.global]] interaction = \u0026#34;PDNS\u0026#34; potential = \u0026#34;PDNS\u0026#34; spatial_partition.type = \u0026#34;VerletList\u0026#34; spatial_partition.margin = 0.5 sigma = 1.0 delta = 0.17453 parameters = [ {index = 2, kind = \u0026#34;DNA\u0026#34;, S3 = 1}, {index = 5, kind = \u0026#34;DNA\u0026#34;, S3 = 4}, # ... {index = 1000, offset = 100, kind = \u0026#34;Protein\u0026#34;, PN = 999, PC = 1001, k = -1.2, r0 = 5.0, theta0 = 1.57, phi0 = 1.73}, {index = 1023, offset = 100, kind = \u0026#34;Protein\u0026#34;, PN = 1022, PC = 1024, k = -1.2, r0 = 6.0, theta0 = 1.57, phi0 = 1.73}, # ... ] Input Reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;PDNS\u0026quot;.   potential: String  Name of the potential. Here, it is \u0026quot;PDNS\u0026quot;.   sigma: Floating  The width of the attractive potential along the radial direction.   delta: Floating  The width of the attractive potential along the angle direction.   parameters: Array of Tables  index: Integer  The index of the particle. In DNA case, the index of the phosphate.   offset: Integer (Optional. By default, 0)  Offset of the index.   kind: String  There are 2 kinds of particles, DNA and Protein.   S3: Integer  Only required for DNA. The index of sugar particle of adjacent nucleotide towords the 3\u0026rsquo; end.   PN, PC: Integer  Only required for Protein. The adjacent particle towords N- and C-terminus, respectively.   k: Floating  The strength of the potential.   r0, theta0, phi0: Floating  The native conformation.      "}),e.add({id:40,href:"/Mjolnir/docs/reference/forcefields/external/AFMFittingInteraction/",title:"AFMFitting",section:"External",content:"AFMFittingInteraction #  Flexible fitting potential to an AFM image.\nIt is developed in the following paper.\n T. Niina et al., JCTC (2020)    \\[\\begin{aligned} U(\\mathbf{r}) \u0026amp;= k(1 - \\mathrm{c.c.}(\\mathbf{r})) \\\\ \\mathrm{c.c.} \u0026amp;= \\frac{\\sum_{p\\in\\mathrm{pixels}} H_p^{\\mathrm{(exp)}} H_p^{\\mathrm{(sim)}}(\\mathbf{r})} {\\sqrt{\\sum_{p\\in\\mathrm{pixels}} \\left(H_p^{\\mathrm{(exp)}}\\right)^2} \\sqrt{\\sum_{p\\in\\mathrm{pixels}} \\left(H_p^{\\mathrm{(sim)}}(\\mathbf{r})\\right)^2}} \\\\ H_p^{\\mathrm{(sim)}}(\\mathbf{r}) \u0026amp;= \\gamma\\log\\left(1 \u0026#43; \\sum_i^N \\exp\\left(\\frac{-(x_i - x_p)^2 - (y_i - y_p)^2 }{2\\sigma^2}\\right)\\exp\\left(\\frac{z_i \u0026#43; r_i}{\\gamma}\\right)\\right) \\end{aligned}\\]  Example #  [[forcefields.external]] interaction = \u0026#34;AFMFlexibleFitting\u0026#34; k = 100.0 gamma = 1.0 pixel_x = 10.0 pixel_y = 10.0 length_x = 5 length_y = 5 sigma_x = 2.0 sigma_y = 2.0 z0 = 0.0 cutoff = 5.0 margin = 0.5 image = [  0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.5, 1.0, 0.5,  0.0, 0.0, 1.0, 2.0, 1.0,  0.0, 0.0, 0.5, 1.0, 0.5, ] parameters = [ {index = 0, radius = 1.0}, {index = 1, radius = 2.0}, {index = 4, radius = 3.0}, {index = 5, radius = 4.0}, ] Input Reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;AFMFlexibleFitting\u0026quot;.   k: Floating  It determines the strength of the potential.   gamma: Floating  It determines the accuracy of the softmax.   pixel_x, pixel_y: Floating  The pixel size along each axis.   length_x, length_y: Integer  The number of pixels along each axis.   sigma_x, sigma_y: Floating   \\( \\sigma \\)  values in  \\( H \\)  function along each axis.   z0: Floating  A parameter to reduce the numerical error internally. Normally, 0 is okay.   cutoff: Floating  Cutoff length for the gaussian relative to  \\( \\sigma \\)  .   margin: Floating  Margin used in the internal neighboring list, relative to the cutoff length.   image: Array of Floatings  The reference image. Each pixel has height in z direction. The first element has (0, 0) pixel, (1, 0) pixel, \u0026hellip; (Lx, 0) pixel, (0, 1) pixel, \u0026hellip; and so on. The (0, 0) pixel is the rectangular region from the origin, (0.0, 0.0), to (pixel_x, pixel_y). The (n, m) pixel is the rectangular region from (n*pixel_x, m*pixel_y) to ((n+1) pixel_x, (m+1)*pixel_y).   parameters: Array of Tables  index: Integer  The index of the particle.   radius: Floating  The radius of the particle.      "}),e.add({id:41,href:"/Mjolnir/docs/reference/forcefields/local/contact/",title:"Contact",section:"Local",content:"ContactInteraction #  ContactInteraction is an interaction that depends on the distance between particles.\nBasically it is the same as BondLength. But it contains a neighboring list and it skips the calculation if the distance exceeds the cutoff.\nThe following potentials are available.\n Gaussian GoContact AttractiveGoContact RepulsiveGoContact  Example #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;GoContact\u0026#34; topology = \u0026#34;bond\u0026#34; margin = 0.5 # relative length to longest cutoff parameters = [  # required parameters depend on a potential...  {indices = [0, 1], ... }, ] Input Reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;BondLength\u0026quot;.   potential: String  The following potentials are available. Gaussian GoContact AttractiveGoContact RepulsiveGoContact   topology: String  Name of the connection in Topology.   margin: Floating  The margin in the neighboring list. It is relative to the maximum cutoff distance.   parameters: Array of Tables  indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.   The other parameter depends on the specified potential.    "}),e.add({id:42,href:"/Mjolnir/docs/reference/forcefields/local/3SPN2BaseStackingInteraction/",title:"3SPN2 BaseStacking",section:"Local",content:"3SPN2BaseStackingInteraction #  3SPN2BaseStackingInteraction is specific to 3SPN2 Coarse-Grained DNA model.\nThe following potentials are available.\n \u0026quot;3SPN2\u0026quot; (Hinckley et al., (2013) JCP) \u0026quot;3SPN2C\u0026quot; (Freeman et al., (2014) JCP)  Example #  [[forcefields.local]] interaction = \u0026#34;3SPN2BaseStacking\u0026#34; potential = \u0026#34;3SPN2\u0026#34; topology = \u0026#34;nucleotide\u0026#34; parameters = [ # `nucleotide` index starts from 5\u0026#39; and ends at 3\u0026#39;. {strand = 0, nucleotide = 0, S = 0, B = 1, offset = 100, Base = \u0026#34;A\u0026#34;}, {strand = 0, nucleotide = 1, P = 2, S = 3, B = 4, offset = 100, Base = \u0026#34;T\u0026#34;}, {strand = 0, nucleotide = 2, P = 5, S = 6, B = 7, offset = 100, Base = \u0026#34;C\u0026#34;}, {strand = 0, nucleotide = 3, P = 8, S = 9, B = 10, offset = 100, Base = \u0026#34;G\u0026#34;}, {strand = 1, nucleotide = 4, S = 11, B = 12, offset = 100, Base = \u0026#34;C\u0026#34;}, {strand = 1, nucleotide = 5, P = 13, S = 14, B = 15, offset = 100, Base = \u0026#34;G\u0026#34;}, {strand = 1, nucleotide = 6, P = 16, S = 17, B = 18, offset = 100, Base = \u0026#34;A\u0026#34;}, {strand = 1, nucleotide = 7, P = 19, S = 20, B = 21, offset = 100, Base = \u0026#34;T\u0026#34;}, ] Input Reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;3SPN2BaseStacking\u0026quot;.   potential: String  Name of the potential. One of the following. 3SPN2 3SPN2C   topology: String  Name of the topology. Debye-Huckel and 3SPN2BaseBaseInteraction should handle this correctly. This interaction adds edges between all the pair of nucleotide particles that are next to each other.   parameters: Array of Tables  strand: Integer  Index of the strand.   nucleotide: Integer  Index of the nucleotide.   P, S, B: Integer  Indices of particles that correspond to phosphate (P), sugar (S), and base (B). The index is 0-based.   offset: Integer (Optional. By default, 0.)  The offset value for the index.   Base: String  One of \u0026quot;A\u0026quot;, \u0026quot;T\u0026quot;, \u0026quot;C\u0026quot; or \u0026quot;G\u0026quot;.   Normally nucleotide at the edge of the DNA does not have phosphate.    "}),e.add({id:43,href:"/Mjolnir/docs/reference/forcefields/external/PullingForceInteraction/",title:"PullingForce",section:"External",content:"PullingForce #  It applies a force to the specified particle.\nExample #  [[forcefields.external]] interaction = \u0026#34;PullingForce\u0026#34; parameters = [  {index = 0, force = [1.0, 0.0, 0.0]},  {index = 0, force = 1.0, direction = [1.0, 1.0, 1.0]},  # ... ] Input Reference #   interaction: String  Name of the interaciton. Here, it is \u0026quot;PullingForce\u0026quot;.   parameters: Table  index: Integer  The index of the particle. The index is 0-based.   force: Array of Floatings (length = 3) or Floating  If it is an Array of Floatings, it represents the force to apply. If it is Floating, it represents the strength of the force. In that case direction must be provided. The unit depends on the unit system you choose in [units] (e.g. kcal/mol/Å).  1 kcal/mol/Å ~ 69.5 pN.     direction: Array of Floatings  The cartesian coordinate (x, y, and z in this order) of the force direction. It will be normalized.      "}),e.add({id:44,href:"/Mjolnir/docs/reference/forcefields/external/CoMPullingForceInteraction/",title:"CoMPullingForce",section:"External",content:"CoMPullingForce #  It applies a force to the center of mass of the specified particles.\nExample #  [[forcefields.external]] interaction = \u0026#34;CoMPullingForce\u0026#34; parameters = [  {indices = [0, 1, 2], force = [0.0, 0.0, 0.0144]},  {indices = \u0026#34;[0, 10)\u0026#34;, force = 0.0144, direction = [1.0, 1.0, 1.0]},  {indices = [\u0026#34;[0, 99]\u0026#34;, \u0026#34;[200, 300)\u0026#34;], force = 0.0144, direction = [1.0, 1.0, 1.0]},  # ... ] Input Reference #   interaction: String  Name of the interaciton. Here, it is \u0026quot;CoMPullingForce\u0026quot;.   parameters: Table  indices: Array of Integers, String, or Array of Strings  The indices of the particles. If it is an Array of Integers, then the integers will be the indices of the particles. If it is a String, the string will be interpreted as an interval of the indices by a standard form. A string \u0026quot;[0, 10)\u0026quot; means integers from 0 to 9 (half-open interval). If it is an Array of Strings, then the intervals will be concatenated. Note that the indices will be made unique.   force: Array of Floatings (length = 3) or Floating  If it is an Array of Floatings, it represents the force to apply. If it is Floating, it represents the strength of the force. In that case direction must be provided. The unit depends on the unit system you choose in [units] (e.g. kcal/mol/Å).  1 kcal/mol/Å ~ 69.5 pN.     direction: Array of Floatings  The cartesian coordinate (x, y, and z in this order) of the force direction. It will be normalized.      "}),e.add({id:45,href:"/Mjolnir/docs/reference/forcefields/local/DummyInteraction/",title:"Dummy",section:"Local",content:"DummyInteraction #  DummyInteraction does not calculate anything. No potential is available.\nIt is provided to add a connection between particles in its Topology without make the particles interact. That means that, this interaction enables to ignore some of the global interactions without having local interaction.\nFor more detail about topology, see Topology.\nExample #  [[forcefields.local]] interaction = \u0026#34;Dummy\u0026#34; # No potential field required. topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], offset = 100}, # No other parameters.  # ... ] Input reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;Dummy\u0026quot;.   topology: String  Name of the connection in Topology.   parameters: Array of Tables  indices: Array of Integers (length = 2)  The indices of particles to be connected. The index is 0-based.   offset: Integer (Optional. By default, 0.)  Offset of index.      "}),e.add({id:46,href:"/Mjolnir/docs/reference/forcefields/local/dihedral/CosinePotential/",title:"Cosine",section:"DihedralAngle",content:"CosinePotential #  Cosine potential is a periodic alternative of harmonic potential for dihedral angle interaction.\nThe functional form is the following.\n  \\[U(v) = k\\left(1 \u0026#43; \\cos(n(v - v_0))\\right)\\]  Example #  [[forcefields.local]] interaction = \u0026#34;DihedralAngle\u0026#34; potential = \u0026#34;Cosine\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1, 2, 3], v0 = 1.57, k = 10.0, n = 1}, ] Input Reference #   k: Floating  It determines the strength of the potential.   n: Integer  It determines the number of minima in the potential.   v0: Floating  It determines the position of minima.   indices: Array of Integers (length = 4)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:47,href:"/Mjolnir/docs/reference/forcefields/local/contact/GaussianPotential/",title:"Gaussian",section:"Contact",content:"GaussianPotential #  The well-known, widely-used gaussian function.\n  \\[U(v) = k\\exp\\left(\\frac{-(v - v_0)^2}{2\\sigma^2}\\right)\\]  Example #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;Gaussian\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = -100.0, sigma = 5.0},  # ... ] Input Reference #   k: Floating  It determines the strength of the potential. If positive, the gaussian becomes repulsive.   sigma: Floating  It determines the width of the gaussian.   v0: Floating  It determines the peak of the gaussian.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:48,href:"/Mjolnir/docs/reference/forcefields/local/bondangle/HarmonicPotential/",title:"Harmonic",section:"BondAngle",content:"HarmonicPotential #  Well-known and widely-used harmonic function.\n  \\[U(v) = k(v-v_0)^2\\]  Example #  [[forcefields.local]] interaction = \u0026#34;BondAngle\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1, 2], offset = 100, v0 = 1.0, k = 100.0},  # ... ] Input Reference #   k: Floating  It determines the strength of the potential.   v0: Floating  It determines the native length.   indices: Array of Integers (length = 3)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:49,href:"/Mjolnir/docs/reference/forcefields/local/bondlength/HarmonicPotential/",title:"Harmonic",section:"BondLength",content:"HarmonicPotential #  Well-known and widely-used harmonic function.\n  \\[U(v) = k(v-v_0)^2\\]  Example #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], offset = 100, v0 = 1.0, k = 100.0},  # ... ] Input Reference #   k: Floating  It determines the strength of the potential.   v0: Floating  It determines the native length.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:50,href:"/Mjolnir/docs/reference/forcefields/external/distance/LennardJonesWallPotential/",title:"LennardJones",section:"Distance",content:"LennardJonesWallPotential #  It is a 6-12 Lennard Jones potential between particle and a spatial structure.\n  \\[U(r) = 4\\epsilon\\left(\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right)\\]  Example #  [[forcefields.external]] interaction = \u0026#34;Distance\u0026#34; potential = \u0026#34;LennardJonesWall\u0026#34; shape.name = \u0026#34;AxisAlignedPlane\u0026#34; shape.axis = \u0026#34;X\u0026#34; shape.position = 0.0 shape.margin = 0.5  parameters = [  {index = 0, sigma = 1.0, epsilon = 0.1},  # ... ] Input Reference #   sigma: Floating  It determines the effective size of the particle.   epsilon: Floating  It determines the strength of the potential.    "}),e.add({id:51,href:"/Mjolnir/docs/reference/forcefields/external/rectangularbox/LennardJonesWallPotential/",title:"LennardJones",section:"RectangularBox",content:"LennardJonesWallPotential #  It is a 6-12 Lennard Jones potential between particle and a spatial structure.\n  \\[U(r) = 4\\epsilon\\left(\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right)\\]  Example #  [[forcefields.external]] interaction = \u0026#34;RectangularBox\u0026#34; box.lower = [ 0.0, 0.0, 0.0] box.upper = [100.0, 100.0, 100.0] box.margin = 0.4  potential = \u0026#34;LennardJonesWall\u0026#34; parameters = [  {index = 0, sigma = 1.0, epsilon = 0.1},  # ... ] Input Reference #   sigma: Floating  It determines the effective size of the particle.   epsilon: Floating  It determines the strength of the potential.    "}),e.add({id:52,href:"/Mjolnir/docs/reference/forcefields/global/pair/LennardJonesPotential/",title:"LennardJones",section:"Pair",content:"LennardJonesPotential #  The well-known Lennard-Jones potential.\n  \\[U(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]  Example #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJones\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2}  cutoff = 2.5 parameters = [  {index = 0, offset = 100, sigma = 2.0, epsilon = 10.0}, ] Input Reference #  To calculate  \\( \\sigma \\)  and  \\( \\epsilon \\)  for each pair, Lorentz-Berthelot combining rules are used.\n \\[\\sigma_{ij} = \\frac{\\sigma_i \u0026#43; \\sigma_j}{2} \\\\ \\epsilon_{ij} = \\sqrt{\\epsilon_i\\epsilon_j}\\]   cutoff: Floating (Optional. By default, 2.5.)  The cutoff distance relative to the maximum  \\(\\sigma_{ij}\\)  .   index: Integer  The index of the particle.   offset: Integer (ptional. By default, 0.)  Offset value of the index.   sigma: Floating  It determines the effective particle size.   epsilon: Integer  It determines the strength of the potential.    For other values, see Pair.\n"}),e.add({id:53,href:"/Mjolnir/docs/reference/forcefields/external/distance/ExcludedVolumeWallPotential/",title:"ExcludedVolume",section:"Distance",content:"ExcludedVolumeWallPotential #  It is a excluded volume potential between particle and a spatial structure.\n  \\[U(r) = \\epsilon\\left(\\frac{r_0}{r}\\right)^{12}\\]  Example #  [[forcefields.external]] interaction = \u0026#34;Distance\u0026#34; potential = \u0026#34;ExcludedVolumeWall\u0026#34; shape.name = \u0026#34;AxisAlignedPlane\u0026#34; shape.axis = \u0026#34;X\u0026#34; shape.position = 0.0 shape.margin = 0.5  epsilon = 0.5 parameters = [  {index = 0, radius = 1.0},  # ... ] Input Reference #   epsilon: Floating  It determines the strength of the potential.   radius: Floating  It determines the effective radius of the particle.    "}),e.add({id:54,href:"/Mjolnir/docs/reference/forcefields/external/rectangularbox/ExcludedVolumeWallPotential/",title:"ExcludedVolume",section:"RectangularBox",content:"ExcludedVolumeWallPotential #  It is a excluded volume potential between particle and a spatial structure.\n  \\[U(r) = \\epsilon\\left(\\frac{r_0}{r}\\right)^{12}\\]  Example #  [[forcefields.external]] interaction = \u0026#34;RectangularBox\u0026#34; box.lower = [ 0.0, 0.0, 0.0] box.upper = [100.0, 100.0, 100.0] box.margin = 0.4  potential = \u0026#34;LennardJonesWall\u0026#34; epsilon = 0.5 parameters = [  {index = 0, radius = 1.0},  # ... ] Input Reference #   epsilon: Floating  It determines the strength of the potential.   radius: Floating  It determines the effective radius of the particle.    "}),e.add({id:55,href:"/Mjolnir/docs/reference/forcefields/local/bondangle/GaussianPotential/",title:"Gaussian",section:"BondAngle",content:"GaussianPotential #  The well-known, widely-used gaussian function.\n  \\[U(v) = k\\exp\\left(\\frac{-(v - v_0)^2}{2\\sigma^2}\\right)\\]  Example #  [[forcefields.local]] interaction = \u0026#34;BondAngle\u0026#34; potential = \u0026#34;Gaussian\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1, 2], v0 = 1.0, k = -100.0, sigma = 5.0},  # ... ] Input Reference #   k: Floating  It determines the strength of the potential. If positive, the gaussian becomes repulsive.   sigma: Floating  It determines the width of the gaussian.   v0: Floating  It determines the peak of the gaussian.   indices: Array of Integers (length = 3)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:56,href:"/Mjolnir/docs/reference/forcefields/local/bondlength/GaussianPotential/",title:"Gaussian",section:"BondLength",content:"GaussianPotential #  The well-known, widely-used gaussian function.\n  \\[U(v) = k\\exp\\left(\\frac{-(v - v_0)^2}{2\\sigma^2}\\right)\\]  Example #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Gaussian\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = -100.0, sigma = 5.0},  # ... ] Input Reference #   k: Floating  It determines the strength of the potential. If positive, the gaussian becomes repulsive.   sigma: Floating  It determines the width of the gaussian.   v0: Floating  It determines the peak of the gaussian.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:57,href:"/Mjolnir/docs/reference/forcefields/local/dihedral/GaussianPotential/",title:"Gaussian",section:"DihedralAngle",content:"GaussianPotential #  The well-known, widely-used gaussian function.\n  \\[U(v) = k\\exp\\left(\\frac{-(v - v_0)^2}{2\\sigma^2}\\right)\\]  This function is not strictly periodic, so the  \\( \\sigma \\)  should be enough small relative to  \\( \\pi \\)  .\nExample #  [[forcefields.local]] interaction = \u0026#34;DihedralAngle\u0026#34; potential = \u0026#34;Gaussian\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1, 2, 3], v0 = 1.0, k = -100.0, sigma = 5.0},  # ... ] Input Reference #   k: Floating  It determines the strength of the potential. If positive, the gaussian becomes repulsive.   sigma: Floating  It determines the width of the gaussian.   v0: Floating  It determines the peak of the gaussian.   indices: Array of Integers (length = 4)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:58,href:"/Mjolnir/docs/reference/forcefields/local/contact/GoContactPotential/",title:"GoContact",section:"Contact",content:"GoContactPotential #  Go-Contact potential is a kind of 10-12 Lennard Jones potential.\n  \\[U(r) = k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right]\\]  It is mainly used in a structure-based Coarse-Grained models to represent attractive pairs of particles.\nExample #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;GoContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] Input Reference #   v0: Floating  The native distance.  \\( r_0 \\)  in the above equation.   k: Floating  The strength of the potential.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:59,href:"/Mjolnir/docs/reference/forcefields/global/pair/UniformLennardJonesPotential/",title:"UniformLennardJones",section:"Pair",content:"UniformLennardJonesPotential #  The well-known Lennard-Jones potential.\n  \\[U(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]  It is a special case where all the particles has the same parameter.\nExample #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;UniformLennardJones\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2}  cutoff = 2.5 sigma = 2.0 epsilon = 0.5 parameters = [  {index = 0, offset = 100}, # to control which particle participates ] Input Reference #   cutoff: Floating (Optional. By default, 2.5.)  The cutoff distance relative to the maximum  \\(\\sigma_{ij}\\)  .   index: Integer  The index of the particle.   offset: Integer (ptional. By default, 0.)  Offset of the index.   sigma: Floating  It determines the effective particle size.   epsilon: Integer  It determines the strength of the potential.    For other values, see Pair.\n"}),e.add({id:60,href:"/Mjolnir/docs/reference/forcefields/local/contact/AttractiveGoContact/",title:"AttractiveGo",section:"Contact",content:"AttractiveGoContactPotential #  Attractive part of the Go-Contact potential.\n  \\[U(r) = \\begin{cases} -k \u0026amp; (r \u0026lt; r_0) \\\\ k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right] \u0026amp; otherwise \\end{cases}\\]  Example #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;AttractiveGoContact\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] Input Reference #   v0: Floating  The native distance.  \\( r_0 \\)  in the above equation.   k: Floating  The strength of the potential.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:61,href:"/Mjolnir/docs/reference/forcefields/global/pair/DebyeHuckelPotential/",title:"DebyeHückel",section:"Pair",content:"DebyeHückelPotential #  It is a electrostatic potential in an ionic solution based on Debye-Hückel equation.\n  \\[U(r_{ij}) = \\frac{q_i q_j}{4\\pi\\epsilon_0\\epsilon_k r_{ij}} \\exp(-r_{ij}/\\lambda_D)\\]   \\[\\lambda_D = \\sqrt{\\frac{\\epsilon_0\\epsilon_k}{2\\beta N_A e_c^2 I}}\\]  The permittivity of the water is derived from the same equation used in the following papers.\n Sambriski, E. J. et al., (2009) Biophys. J. Hinckley, D. M. et al., (2013) JCP. Freeman, G. S., et al., (2014) JCP.  Example #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;DebyeHuckel\u0026#34; ignore.particles_within.bond = 3 spatial_partition.type = \u0026#34;CellList\u0026#34; spatial_partition.margin = 0.2 cutoff = 5.5 parameters = [  {index = 0, charge = 1.0}, ] Input Reference #  This potential requires system attribute, temperature and ionic_strength.\n cutoff: Floating (Optional. By default, 5.5.)  Cutoff length relative to the debye length.   index: Integer  The index of the particle.   offset: Integer (ptional. By default, 0.)  Offset value of the index.   charge: Floating  The value of charge of the particle.    "}),e.add({id:62,href:"/Mjolnir/docs/reference/forcefields/local/bondangle/FlexibleLocalAnglePotential/",title:"FlexibleLocal",section:"BondAngle",content:"FlexibleLocalAngle #  It represents angle distribution of flexible regions of proteins in a Coarse-Grained protein model. Since it represents a distribution, it is based on values on grid points and interpolates those values.\nIt is a component of AICG2+ Coarse-Grained protein model.\nIt is developed in the following paper.\n T. Terakawa and S. Takada, (2011) Biophys J.  Example #  [[forcefields.local]] interaction = \u0026#34;BondAngle\u0026#34; potential = \u0026#34;FlexibleLocalAngle\u0026#34; topology = \u0026#34;none\u0026#34; env.x = [ 1.3090, 1.4835, 1.6581, 1.8326, 2.0071, 2.1817, 2.3562, 2.5307, 2.7053, 2.8798] env.y1_ALA = [ 5.00, 1.34, 0.84, 1.17, 0.82, 1.00, 1.27, 1.52, 3.20, 10.00] env.y2_ALA = [ 0.00, 151.96, 14.61, -46.89, 39.04, -4.86, -1.86, 8.38, 250.03, 0.00] parameters = [  {indices = [0, 1, 2], k = 1.0, x = \u0026#34;x\u0026#34;, y = \u0026#34;y1_ALA\u0026#34;, d2y = \u0026#34;y2_ALA\u0026#34;},  # ... ] Input Reference #   k: Floating  It determines the strength of the potential.   x: Array of Floating (length = 10. Optional. By default, use default value in AICG2+).  Grid points on which the values are specified. The unit is the radian. It should be equidistant.   y: Array of Floating (length = 10)  Potential energy value at each grid point.   d2y: Array of Floating (length = 10)  Second derivative of potential energy value at each grid point.   indices: Array of Integers (length = 3)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:63,href:"/Mjolnir/docs/reference/forcefields/local/dihedral/FlexibleLocalDihedralPotential/",title:"FlexibleLocal",section:"DihedralAngle",content:"FlexibleLocalDihedral #  It represents dihedral angle distribution of flexible regions of proteins in a Coarse-Grained protein model.\n  \\[U(\\phi) = C \u0026#43; \\sum_{n=1}^{3}\\left( k_n^{\\sin} \\sin(n\\phi) \u0026#43; k_n^{\\cos} \\cos(n\\phi)\\right)\\]  It is a component of AICG2+ Coarse-Grained protein model.\nIt is developed in the following paper.\n T. Terakawa and S. Takada, (2011) Biophys J  Example #  [[forcefields.local]] parameters = [  {indices = [0,1,2,3], k = 1.0, coef = [2.2356, 0.4119, -0.1283, 0.0229, -0.2708, -0.0085, -0.0641]},  # ... ] Input Reference #   k: Floating  It determines the strength of the potential.   coef: Array of Floatings (length = 7)   \\( C, k_1^{\\sin}, k_1^{\\cos}, k_2^{\\sin}, k_2^{\\cos}, k_3^{\\sin}, k_3^{\\cos} \\)  , respectively.   indices: Array of Integers (length = 4)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:64,href:"/Mjolnir/docs/reference/forcefields/local/bondlength/GoContactPotential/",title:"GoContact",section:"BondLength",content:"GoContactPotential #  10-12 Lennard Jones potential.\n  \\[U(r) = k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right]\\]  It is mainly used in a structure-based Coarse-Grained models to represent attractive pairs of particles.\nExample #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;GoContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] Input Reference #   v0: Floating  The native distance.  \\( r_0 \\)  in the above equation.   k: Floating  The strength of the potential.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:65,href:"/Mjolnir/docs/reference/forcefields/external/distance/ImplicitMembranePotential/",title:"ImplicitMembrane",section:"Distance",content:"ImplicitMembranePotential #  It is a implicit membrane model that stabilizes the region around the plane.\n  \\[U(\\mathbf{r}) = \\sum_i^N k h_i \\tanh\\left(\\mathrm{bend} * \\left(|z_i - z_0| - \\frac{\\mathrm{thickness}}{2}\\right)\\right)\\]  Example #  [[forcefields.external]] interaction = \u0026#34;Distance\u0026#34; potential = \u0026#34;ImplicitMembrane\u0026#34; shape.name = \u0026#34;AxisAlignedPlane\u0026#34; shape.axis = \u0026#34;X\u0026#34; shape.position = 0.0 shape.margin = 0.5  bend = 1.0 thickness = 4.0 interaction_magnitude = 10.0 parameters = [  {index = 0, hydrophobicity = 1.0},  # ... ] Input Reference #   bend: Floating  It modelates the slope between stabilized region and the planner region.   thickness: Floating  It determines the region where the stabilized.   interaction_magnitude: Floating  It determines the strength of the potential.  \\( k \\)  in the above equation.   parameters: Array of Tables  index: Integer  The index of the particle. The index is 0-based.   hydrophobicity: Floating  The hydrophobicity of the particle.  \\( h \\)  in the above equation.      Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:66,href:"/Mjolnir/docs/reference/forcefields/local/bondlength/AttractiveGoContact/",title:"AttractiveGo",section:"BondLength",content:"AttractiveGoContactPotential #  Attractive part of the Go-Contact potential.\n  \\[U(r) = \\begin{cases} -k \u0026amp; (r \u0026lt; r_0) \\\\ k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right] \u0026amp; otherwise \\end{cases}\\]  Example #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;AttractiveGoContact\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] Input Reference #   v0: Floating  The native distance.  \\( r_0 \\)  in the above equation.   k: Floating  The strength of the potential.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:67,href:"/Mjolnir/docs/reference/forcefields/local/dihedral/ClementiDihedralPotential/",title:"ClementiDihedral",section:"DihedralAngle",content:"ClementiDihedral #  It is specific to Off-lattice Go forcefield.\n  \\[U(v) = k_1(1-\\cos(v-v_0)) \u0026#43; k_3(1-\\cos(3(v-v_0)))\\]  It is introduced in the following paper.\n C. Clementi, H. Nymeyer, J. Onuchic, (2000) JMB  Example #  [[forcefields.local]] interaction = \u0026#34;DihedralAngle\u0026#34; potential = \u0026#34;ClementiDihedral\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0,1,2,3], v0 = -2.20, k1 = 1.0, k3 = 0.5},  # ... ] Input Reference #   v0: Floating  It determines the minimum of the potenital.   k1: Floating  It determines the strength of the potential.   k3: Floating  It determines the strength of the potential.   indices: Array of Integers (length = 4)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:68,href:"/Mjolnir/docs/reference/forcefields/global/pair/ExcludedVolumePotential/",title:"ExcludedVolume",section:"Pair",content:"ExcludedVolume #  A simple excluded volume potential.\n  \\[U(r) = \\epsilon\\left(\\frac{\\sigma}{r}\\right)^{12}\\]  Example #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;ExcludedVolume\u0026#34;  ignore.particles_within.bond = 3 ignore.particles_within.contact = 1  spatial_partition.type = \u0026#34;CellList\u0026#34; spatial_partition.margin = 0.2  cutoff = 2.5 epsilon = 0.2 parameters = [  {index = 0, radius = 2.0} ] Input Reference #   cutoff: Floating (Optional. By default, 2.)  Cutoff distance relative to the  \\( \\sigma_{ij} \\)  .   epsilon: Floating  It determines the strength of the potential.   index: Integer  The index of the particle. The index is 0-based.   offset: Integer (Optional. By default, 0)  Offset for the index.   radius: Floating  It determines the effective size of the particle.  \\( \\sigma \\)  in the above equation is a sum of the radii.    "}),e.add({id:69,href:"/Mjolnir/docs/reference/forcefields/local/contact/RepulsiveGoContact/",title:"RepulsiveGo",section:"Contact",content:"RepulsiveGoContactPotential #  Repulsive part of the Go-Contact potential.\n  \\[U(r) = \\begin{cases} k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10} \u0026#43; 1\\right] \u0026amp; r \u0026lt; r_0 \\\\ 0 \u0026amp; otherwise \\end{cases}\\]  Example #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;AttractiveGoContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] Input Reference #   v0: Floating  The native distance.  \\( r_0 \\)  in the above equation.   k: Floating  The strength of the potential.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:70,href:"/Mjolnir/docs/reference/forcefields/local/contact/AttractiveMBasinContact/",title:"AttractiveMBasin",section:"Contact",content:"AttractiveMBasinContactPotential #  Attractive part of the Go-Contact potential specifically used in MultipleBasin forcefield.\n  \\[U(r) = k\\min\\left(0, 5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right)\\]  Example #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;AttractiveMBasinContact\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] Input Reference #   v0: Floating  The native distance.  \\( r_0 \\)  in the above equation.   k: Floating  The strength of the potential.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:71,href:"/Mjolnir/docs/reference/forcefields/global/pair/InversePowerPotential/",title:"InversePower",section:"Pair",content:"InversePowerPotential #  It is a generalized excluded volume potential.\n  \\[U(r) = \\epsilon\\left(\\frac{\\sigma}{r}\\right)^{n}\\]  Example #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;InversePower\u0026#34;  ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 ignore.groups.intra = [\u0026#34;chain-A\u0026#34;] ignore.groups.inter = [[\u0026#34;chain-B\u0026#34;, \u0026#34;chain-C\u0026#34;]]  spatial_partition.type = \u0026#34;CellList\u0026#34; spatial_partition.margin = 0.2  cutoff = 2.5 epsilon = 0.2 n = 5 parameters = [  {index = 0, radius = 2.0} ] Input Reference #   cutoff: Floating (Optional. By default,  \\(2^{\\frac{12}{n}}\\)  .)  Cutoff distance relative to the  \\( \\sigma_{ij} \\)  .   epsilon: Floating  It determines the strength of the potential.   n: Integer  It determines the slope of the potential.   index: Integer  The index of the particle. The index is 0-based.   offset: Integer (Optional. By default, 0)  Offset for the index.   radius: Floating  It determines the effective size of the particle.  \\( \\sigma \\)  in the above equation is a sum of the radii.    Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:72,href:"/Mjolnir/docs/reference/forcefields/local/bondlength/RepulsiveGoContact/",title:"RepulsiveGo",section:"BondLength",content:"RepulsiveGoContactPotential #  Repulsive part of the Go-Contact potential.\n  \\[U(r) = \\begin{cases} k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10} \u0026#43; 1\\right] \u0026amp; r \u0026lt; r_0 \\\\ 0 \u0026amp; otherwise \\end{cases}\\]  Example #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;RepulsiveGoContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] Input Reference #   v0: Floating  The native distance.  \\( r_0 \\)  in the above equation.   k: Floating  The strength of the potential.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:73,href:"/Mjolnir/docs/reference/forcefields/local/bondlength/AttractiveMBasinContact/",title:"AttractiveMBasin",section:"BondLength",content:"AttractiveMBasinContactPotential #  Attractive part of the Go-Contact potential specifically used in MultipleBasin forcefield.\n  \\[U(r) = k\\min\\left(0, 5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right)\\]  Example #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;AttractiveMBasinContact\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] Input Reference #   v0: Floating  The native distance.  \\( r_0 \\)  in the above equation.   k: Floating  The strength of the potential.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:74,href:"/Mjolnir/docs/reference/forcefields/global/pair/HardCoreExcludedVolumePotential/",title:"HardCore",section:"Pair",content:"HardCoreExcludedVolume #  An excluded volume potential with a hard core that never overlaps to each other.\n  \\[U(r) = \\epsilon\\left(\\frac{\\sigma}{r - r_0}\\right)^{12}\\]  Example #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;HardCoreExcludedVolume\u0026#34;  ignore.particles_within.bond = 3 ignore.particles_within.contact = 1  spatial_partition.type = \u0026#34;CellList\u0026#34; spatial_partition.margin = 0.2  cutoff = 2.5 epsilon = 0.2 parameters = [  {index = 0, core_radius = 3.0, soft_shell_thickness = 2.0},  {index = 1, core_radius = 3.0, soft_shell_thickness = 2.0}, ] Input Reference #   cutoff: Floating (Optional. By default, 2.)  Cutoff distance relative to the  \\( \\sigma_{ij} \\)  .   epsilon: Floating  It determines the strength of the potential.   index: Integer  The index of the particle. The index is 0-based.   offset: Integer (Optional. By default, 0)  Offset for the index.   core_radius: Floating  The size of the core.  \\( r_0 \\)  is a sum of core_radii.   soft_shell_thickness: Floating  The thickness of the soft shell.  \\(\\sigma_{ij}\\)  is a sum of soft_shell_thicknesses.    Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:75,href:"/Mjolnir/docs/reference/forcefields/local/contact/RepulsiveMBasinContact/",title:"RepulsiveMBasin",section:"Contact",content:"RepulsiveMBasinContactPotential #  Repulsive part of the Go-Contact potential specifically used in MultipleBasin forcefield.\n  \\[U(r) = k\\max\\left(0, 5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10})\\]  Example #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;AttractiveMBasinContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] Input Reference #   v0: Floating  The native distance.  \\( r_0 \\)  in the above equation.   k: Floating  The strength of the potential.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:76,href:"/Mjolnir/docs/reference/forcefields/local/bondlength/RepulsiveMBasinContact/",title:"RepulsiveMBasin",section:"BondLength",content:"RepulsiveMBasinContactPotential #  Repulsive part of the Go-Contact potential, specifically used in MultipleBasin forcefield.\n  \\[U(r) = k\\max\\left(0, 5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10})\\]  Example #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;RepulsiveMBasinContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] Input Reference #   v0: Floating  The native distance.  \\( r_0 \\)  in the above equation.   k: Floating  The strength of the potential.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:77,href:"/Mjolnir/docs/reference/forcefields/global/pair/WCAPotential/",title:"WCA",section:"Pair",content:"WCAPotential #  The well-known WCA (Weeks-Chandler-Andersen) potential. It is\n  \\[U(r) = \\begin{cases} 4\\epsilon \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6\\right] \u0026#43; \\epsilon \u0026amp; (r \u0026lt; \\sigma_{ij}\\sqrt[6]{2})\\\\ 0 \u0026amp; (r \\geq \\sigma_{ij}\\sqrt[6]{2})\\\\ \\end{cases}\\]  Example #  There are two different way to define the parameters. You can either use the normal combining rule or define all the pair-paremeters.\nBy defining parameters for each particle, it uses Lorentz-Berthelot combining rule.\n \\[\\sigma_{ij} = \\frac{\\sigma_i \u0026#43; \\sigma_j}{2} \\\\ \\epsilon_{ij} = \\sqrt{\\epsilon_i\\epsilon_j}\\]  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;WCA\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2}  parameters = [  {index = 0, offset = 100, sigma = 2.0, epsilon = 10.0}, ] To provide pair-parameters manually, define table and give names to the particles.\n[[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJonesAttractive\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2} cutoff = 2.5  table.A.A = {sigma = 1.0, epsilon = 2.0} table.A.B = {sigma = 3.0, epsilon = 1.0} # B.A will be the same table.B.B = {sigma = 1.0, epsilon = 1.5} parameters = [  {index = 0, offset = 100, name = \u0026#34;A\u0026#34;},  {index = 1, offset = 100, name = \u0026#34;B\u0026#34;},  # ... ] Input Reference #   index: Integer  The index of the particle.   offset: Integer (optional. By default, 0.)  Offset value of the index.   sigma: Floating  It determines the effective particle size. If no table is given, this is required.   epsilon: Floating  It determines the strength of the potential. If no table is given, this is required.   name: String  Name of the particle. If table is given, this is required.    Since this potential becomes exactly 0 at  \\( r = \\sigma\\sqrt[6]{2} \\)  , always this cutoff distance is used. You don\u0026rsquo;t need to set cutoff.\nFor other values, see Pair.\n"}),e.add({id:78,href:"/Mjolnir/docs/reference/forcefields/global/pair/LennardJonesAttractivePotential/",title:"LennardJonesAttractive",section:"Pair",content:"LennardJonesAttractivePotential #  The attractive part of the Lennard-Jones potential.\n  \\[U(r) = \\begin{cases} -\\epsilon \u0026amp; (r \u0026lt; \\sigma_{ij}\\sqrt[6]{2})\\\\ 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right] \u0026amp; (\\sigma_{ij}\\sqrt[6]{2} \u0026lt; r) \\end{cases}\\]  Example #  There are two different way to define the parameters. You can either use the normal combining rule or define all the pair-paremeters.\n[[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJonesAttractive\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2}  cutoff = 2.5 parameters = [  {index = 0, offset = 100, sigma = 2.0, epsilon = 10.0},  # ... ] To provide pair-parameters manually, define table and give names to the particles.\n[[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJonesAttractive\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2} cutoff = 2.5  table.A.A = {sigma = 1.0, epsilon = 2.0} table.A.B = {sigma = 3.0, epsilon = 1.0} # B.A will be the same table.B.B = {sigma = 1.0, epsilon = 1.5} parameters = [  {index = 0, offset = 100, name = \u0026#34;A\u0026#34;},  {index = 1, offset = 100, name = \u0026#34;B\u0026#34;},  # ... ] Input Reference #   cutoff: Floating (Optional. By default, 2.5.)  The cutoff distance relative to the maximum  \\(\\sigma_{ij}\\)  .   index: Integer  The index of the particle.   offset: Integer (ptional. By default, 0.)  Offset value of the index.   sigma: Floating  It determines the effective particle size. If no table is given, this is required.   epsilon: Integer  It determines the strength of the potential. If no table is given, this is required.   name: String  Name of the particle. If table is given, this is required.    For other values, see Pair.\n"}),e.add({id:79,href:"/Mjolnir/docs/reference/forcefields/local/bondlength/WormLikeChainPotential/",title:"WormLikeChain",section:"BondLength",content:"WormLikeChain #  A potential function based on the Worm-Like chain model.\n  \\[U(r) = \\frac{k_B T}{p} \\left(\\frac{l_c}{4} \\left[ \\frac{1}{1 - \\frac{r}{l_c}} - 1 \\right] - \\frac{r}{4} \u0026#43; \\frac{r^2}{2l_c}\\right)\\]  Example #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;WormLikeChain\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], offset = 100, p = 5.0, lc = 100.0},  # ... ] Input Reference #   p: Floating  The persistent length of the polymer.   lc: Floating  The maximum length of the polymer.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:80,href:"/Mjolnir/docs/reference/forcefields/global/pair/iSoLFAttractivePotential/",title:"iSoLF",section:"Pair",content:"iSoLFAttractivePotential #  iSoLFAttractive attractive part of the iSoLF potential for coarse-grained lipids developed by the following paper.\n Diego Ugarte La Torre and Shoji Takada (2020) J. Chem. Phys 153, 205101  https://doi.org/10.1063/5.0026342      \\[U(r) = \\begin{cases} -\\epsilon_{ij} \u0026amp; r_{ij} \u0026lt; \\sqrt[6]{2}\\sigma_{ij}\\\\ -\\epsilon_{ij} \\cos^2\\left[\\frac{\\pi}{2\\omega_{ij}}(r_{ij} - \\sqrt[6]{2}\\sigma_{ij}) \\right] \u0026amp; (\\sqrt[6]{2}\\sigma_{ij} \u0026lt; r_{ij} \u0026lt; \\sqrt[6]{2}\\sigma_{ij} \u0026#43; \\omega_{ij})\\\\ 0 \u0026amp; (\\sqrt[6]{2}\\sigma_{ij} \u0026#43; \\omega_{ij} \u0026lt; r_{ij}) \\end{cases}\\]  Example #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;iSoLFAttractive\u0026#34; ignore.particles_within = {bond = 1, angle = 1} ignore.group.inter = [  [\u0026#34;T1\u0026#34;, \u0026#34;T3\u0026#34;] ] spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.5} env.popc_epsilon = 0.416 env.popc_omega = 9.867 env.popc_sigma_T = 7.111 parameters = [ {index = 2, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, {index = 3, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, {index = 4, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, {index = 7, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, {index = 8, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, {index = 9, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, # ... ] Input Reference #  To calculate  \\( \\sigma \\)  ,  \\( \\epsilon \\)  and  \\( \\omega \\)  for each pair, Lorentz-Berthelot combining rules are used.\n \\[\\sigma_{ij} = \\frac{\\sigma_i \u0026#43; \\sigma_j}{2} \\\\ \\epsilon_{ij} = \\sqrt{\\epsilon_i\\epsilon_j} \\\\ \\omega_{ij} = \\frac{\\omega_i\\omega_j}{2}\\]   index: Integer  The index of the particle.   offset: Integer (optional. By default, 0.)  Offset value of the index.   sigma: Floating  It determines the effective particle size.   epsilon: Floating  It determines the strength of the potential.   omega: Floating  It determines the width of the attractive well.    Since this potential becomes exactly 0 at  \\( r = \\sqrt[6]{2}\\sigma_{ij} \u0026#43; \\omega_{ij} \\)  , always this cutoff distance is used. You don\u0026rsquo;t need to set cutoff.\nFor other values, see Pair.\n"}),e.add({id:81,href:"/Mjolnir/docs/reference/forcefields/local/bondlength/WormLikeChainOffsetPotential/",title:"WormLikeChainOffset",section:"BondLength",content:"WormLikeChainOffset #  A potential function based on the Worm-Like chain model with distance offset.\n  \\[U(r) = \\begin{cases} 0 \u0026amp; ( r \u0026lt; l_0 ) \\\\ \\frac{k_B T}{p} \\left(\\frac{l_c}{4} \\left[ \\frac{1}{1 - \\frac{r - l_0}{l_c}} - 1 \\right] - \\frac{r - l_0}{4} \u0026#43; \\frac{\\left(r - l_0 \\right)^2}{2l_c}\\right) \u0026amp; ( r \\geq l_0 ) \\\\ \\end{cases}\\]  Example #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;WormLikeChainOffset\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], offset = 100, p = 5.0, lc = 100.0, l0 = 30.0},  # ... ] Input Reference #   p: Floating  The persistent length of the polymer.   lc: Floating  The maximum length of the polymer.   l0: Floating  The offset length of the distance between two particles.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:82,href:"/Mjolnir/docs/reference/forcefields/local/bondlength/3SPN2BondPotential/",title:"3SPN2Bond",section:"BondLength",content:"3SPN2BondPotential #  It is a component of 3SPN2 potential.\n  \\[U(v) = k(v - v_0)^2 \u0026#43; 100k (v - v_0)^4\\]  Example #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;3SPN2Bond\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], offset = 100, v0 = 1.0, k = 10.0},  # ... ] Input Reference #   k: Floating  It determines the strength of the potential.   v0: Floating  It determines the native length.   indices: Array of Integers (length = 2)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.    "}),e.add({id:83,href:"/Mjolnir/docs/reference/forcefields/global/pair/3SPN2ExcludedVolumePotential/",title:"3SPN2ExcludedVolume",section:"Pair",content:"3SPN2ExcludedVolumePotential #  It is specific to 3SPN2 coarse-grained DNA model.\n  \\[U(r) = \\begin{cases} \\epsilon \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - 2\\left(\\frac{\\sigma_{ij}}{r}\\right)^6\\right] \u0026#43; \\epsilon \u0026amp; (r \u0026lt; \\sigma_{ij})\\\\ 0 \u0026amp; (r \\geq \\sigma_{ij})\\\\ \\end{cases}\\]  Example #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;3SPN2ExcludedVolume\u0026#34; ignore.particles_within.bond = 1 ignore.particles_within.angle = 1 ignore.particles_within.dihedral = 1 ignore.particles_within.nucleotide = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.4} parameters = [  {index = 0, kind = \u0026#34;S\u0026#34;},  {index = 1, kind = \u0026#34;A\u0026#34;},  {index = 2, kind = \u0026#34;P\u0026#34;},  {index = 3, kind = \u0026#34;S\u0026#34;}, ] Input Reference #   index: Integer  The index of the particle.   offset: Integer (ptional. By default, 0.)  Offset value of the index.   kind: String  One of the \u0026quot;S\u0026quot;(sugar), \u0026quot;A\u0026quot;, \u0026quot;T\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;G\u0026quot;(base), or \u0026quot;P\u0026quot;(phosphate).    For other values, see Pair.\n"})})()