'use strict';(function(){const t={encode:!1,tokenize:function(e){return e.replace(/[\x00-\x7F]/g,'').split('')}};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/Mjolnir/ja/docs/installation/",title:"Installation",section:"Docs",content:"Installation #  Mjolnirを使用するために必要な手順を説明します。\nPrerequisities #  Mjolnirを使用するために必要なものは概ね以下のようなものです。\n linux or Unix (e.g. OS X) C++11 compatible compiler git Make CMake Boost C++ Library  Operating System #  ファイルのパスを除けば特にlinux/unix固有の機能を使ってはいませんが、テストは linuxとOS Xでしか行っていません。なので基本的に、Windowsでの動作は保証しません。\nC++ compiler #  C++11に対応しているコンパイラが必要です。 現在は殆どの環境でデフォルトのコンパイラが対応しています。\nですが、手に入るなら、できるだけ新しいものを使用して下さい。 常にそうとは限りませんが、コンパイラが新しければより優れた最適化が行われ、 より速いプログラムになると言ってよいでしょう。\nGit #  Mjolnirはtoml11という外部のライブラリをgit submoduleで管理しているため、その ダウンロードのためにGitが必要です。\nCMake #  MjolnirはCMakeを使ってビルドします。なので、CMakeが必要です。\nCMakeはスクリプトの書き方の変遷が比較的速く、基本的には新しいバージョンで動く ことを優先して開発しています。ですので、可能なら最新のバージョンを使って下さい。\nBoost #  MjolnirのテストコードはBoost.Testを使用して書かれています。\nBoostは、インストール済みのものが見つからなければ自動的に適切なバージョンを ダウンロードするようにしていますが、インストール済みのものがあるならそれを使用した 方がビルドが速く済みます。\nBuilding #  Mjolnirをコンパイルする上で必要な手順は以下の通りです。\n$ git clone https://github.com/Mjolnir-MD/Mjolnir.git $ cd Mjolnir $ mkdir build $ cd build $ cmake .. # オプションは後述 $ make $ make test Options for CMake #  よく使うオプションを列挙します。\n -DCMAKE_CXX_COMPILER=/path/to/compiler  CMakeの機能です。使用するコンパイラを指定することができます。   -DUSE_OPENMP=(ON|OFF)  デフォルトでONです。 ONの場合、OpenMPが使用可能なら、OpenMPを使用したコードを含めてコンパイルします。   -DFIND_BOOST=ON  デフォルトでOFFです。 インストール済みのBoostを探します。見つからなければ、ビルドは失敗します。   -DBOOST_ROOT=/path/to/boost  FindBoostの機能です。Boostがインストールされているディレクトリを指定します。   -DSEPARATE_BUILD=(ON|OFF)  デフォルトでOFFです。 ONの場合、分割コンパイルを行います。 何度も変更してコンパイルを繰り返す開発者が時間を短縮するための機能です。   -DBUILD_UNIT_TEST=(ON|OFF)  デフォルトでONです。 ONの場合、ユニットテスト用のコードをコンパイルします。   -DBUILD_INTEGRATION_TEST=(ON|OFF)  デフォルトでONです。 ONの場合、インテグレータの統合テスト用のコードをコンパイルします。   -DSINGLE_PRECISION_SUPPORT=(ON|OFF)  デフォルトでONです。 OFFの場合、float版のコンパイルが抑制されます。単精度浮動小数点数で計算ができなくなるかわりに、コンパイルが速くなります。   -DDOUBLE_PRECISION_SUPPORT=(ON|OFF)  デフォルトでONです。 OFFの場合、double版のコンパイルが抑制されます。倍精度浮動小数点数で計算ができなくなるかわりに、コンパイルが速くなります。   -DUNLIMITED_BOUNDARY_SUPPORT=(ON|OFF)  デフォルトでONです。 OFFの場合、UnlimitedBoundaryのコンパイルが抑制されます。境界条件なしでの計算ができなくなるかわりに、コンパイルが速くなります。   -DPERIODIC_BOUNDARY_SUPPORT=(ON|OFF)  デフォルトでONです。 OFFの場合、PeriodicBoundaryのコンパイルが抑制されます。箱型の周期境界条件での計算ができなくなるかわりに、コンパイルが速くなります。    "}),e.add({id:1,href:"/Mjolnir/ja/docs/reference/",title:"Reference",section:"Docs",content:"Reference #  Mjolnirにはコマンドラインオプションはありません。 設定には入力ファイルを使用し、実行は以下のような形になります。\n$ mjolnir sample.toml ここでは、入力ファイルの主なコンポーネントを紹介します。\nファイルのフォーマットはTOML v1.0.0に準拠します。 TOMLファイルについては公式サイトを参照して下さい。 仕様の日本語への翻訳も提供されています。\n入力ファイルには大きく5つの項目があり、それぞれがテーブル、またはテーブルの配列になっています。\n[files] #  入力ファイルや出力ファイルのファイル名やパス、フォーマットなどの指定を行います。\n[units] #  単位系を設定します。\n[[forcefields]]のエネルギーのパラメータや[[systems]]での粒子の位置など、 ファイルから入力される数値は、ここで指定された単位系として解釈されます。\n[simulator] #  シミュレーションのプロトコルを決めるテーブルです。 時間刻みや、何ステップのシミュレーションを行うか、何ステップごとに出力するかなどを 設定します。また、計算精度や境界条件の設定も行います。\nメインの入力ファイルとは別のファイルとして設定可能です。\n[[systems]] #  系にある粒子や系に属するパラメータ、境界の具体的な形などを設定します。 距離などの単位は[units]での設定に準じます。\n複数のsystemを扱うシミュレーションのために、テーブルの配列として定義されています。 通常のシミュレーションでは、一つしか定義されません。\nメインの入力ファイルとは別のファイルとして設定可能です。\n[[forcefields]] #  用いる力場を設定します。 パラメータの単位は[units]での設定に準じます。\n複数の力場を扱うシミュレーションのために、テーブルの配列として定義されています。 通常のシミュレーションでは、一つしか定義されません。\nメインの入力ファイルとは別のファイルとして設定可能です。\nファイルのインクルード #  入力ファイルの全ての箇所で、includeという変数は特別な意味を持ちます。\nincludeは文字列型もしくは文字列の配列型を持つことができ、ファイルを指定することができます。 このファイルのパスは[files]テーブルで指定されるfiles.input.pathの影響を受けます。\n# main.toml [[forcefields]] include = [  \u0026#34;bond-length.toml\u0026#34;,  \u0026#34;bond-angle.toml\u0026#34;  \u0026#34;lennard-jones.toml\u0026#34;, ] このようにファイルを指定すると、そのファイル内に定義されている値がincludeを指定したテーブルの下にマージされます。\n以下のようなファイルを用意した場合、\n# bond-length.toml [[local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; parameters = [  # ... ] 内部的なファイルの内容は以下の形になります。\n[[forcefields]] [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; parameters = [  # ... ] ここで、展開は最初の一回だけ行われ、再帰的な展開はなされないことに注意してください。\n"}),e.add({id:2,href:"/Mjolnir/ja/docs/tutorial/",title:"Tutorial",section:"Docs",content:"Tutorial #  ここでは、入力ファイルの書き方を説明します。\nThe Lennard-Jones fluid #  まずは、Lennard-Jonesポテンシャルによって相互作用する粒子のシミュレーションによって、非局所的な相互作用の書き方を説明します。\nSimple polymer model #  続いて、連続する粒子がバネで繋がった理想的なポリマーのシミュレーションによって、局所的な相互作用の書き方を説明します。\n"}),e.add({id:3,href:"/Mjolnir/ja/docs/developersguide/",title:"Developer's Guide",section:"Docs",content:"Developer\u0026rsquo;s Guide #  （執筆中）\nここでは、Mjolnirの設計理念と、新規な力場や手法を追加する方法を説明します。\n設計指針 #  Mjolnirの設計指針を説明します。\n構成要素 #  Mjolnirの構成要素を概観します。\n"}),e.add({id:4,href:"/Mjolnir/ja/docs/glossary/",title:"Glossary",section:"Docs",content:"Glossary #  Mjolnirのコードで使われる単語の用法を説明します。\nSimulator #  シミュレーション全体のプロトコルです。\n普通のMDシミュレーションなら指定された回数だけ時間積分を行います。\nSimulated Annealingをする際は、時間ステップに応じて系の温度を変えます。\n時刻に応じて力場を変更するシミュレーションでは、複数の力場を管理し、適切な タイミングで入れ替えます。\n実際の力や時間積分の計算は、Simulatorが管理する別のコンポーネントが行います。\nSystem #  シミュレーションされる粒子の一群です。\n粒子の他に、境界条件や系のパラメータ（温度など）、Topologyも管理します。\nTopology #  どの粒子とどの粒子がどのような相互作用で繋がっているかを表すグラフです。\nForceFieldにおいて、結合している粒子には斥力をかけない、というような設定を するために存在します。\nIntegrator #  ForceFieldに計算させた力の値を使って、時間積分を行います。\nForceField #  力場のことを指します。具体的には、PotentialとInteractionの組み合わせです。\nlocal, global, externalの3種類があります。\nLocalForceField #  あらかじめ決まった特定の粒子の間に働く力場です。\n結合長ポテンシャルや結合角ポテンシャル、二面角ポテンシャルなどが代表的です。\nGlobalForceField #  （電荷などのパラメータを持つ）全ての粒子の間に働く力場です。\n分子間力ポテンシャル、静電ポテンシャルなどが代表的です。\nExternalForceField #  外力場との相互作用です。これのみが系全体の並進や回転を生じさせます。\n空間中の特定の点へのアンカーや、系全体を覆う箱などが代表的です。\nInteraction #  力場を構成する要素の一つです。ForceFieldはInteractionとPotentialから成ります。\nどの粒子に力がかかるかを管理し、またPotentialを使って力の向きと大きさを計算します。\n以下のような力場があるとき、\n  \\[U(\\theta) = k(\\theta-\\theta_0)^2,\\]  実際にかかる力は\n \\[\\nabla_i U(\\theta) = \\color{red}(\\nabla_i \\theta) \\color{black} \\frac{dU}{d\\theta}\\]  となります。この赤色の部分を実装したものがInteractionです。\nPotential #  力場を構成する要素の一つです。ForceFieldはInteractionとPotentialから成ります。\nポテンシャル関数に関連するパラメータを管理し、ポテンシャル関数そのものと、その微分を計算します。\n以下のような力場があるとき、\n \\[U(\\theta) = k (\\theta - \\theta_0)^2,\\]  実際にかかる力は\n \\[\\nabla_i U(\\theta) = (\\nabla_i \\theta) \\color{red} \\frac{dU}{d\\theta}\\]  となります。この赤色の部分を実装したものがPotentialです。\nObserver #  エネルギーや粒子の位置、速度をファイルに出力します。\nTraits #  どのような種類のシミュレーションを行うかを決めるタグ型です。\n例えば、OpenMPのときにのみ必要なコードはOpenMPSimulatorTraitsによって特殊化 されます。特殊化されなかったコードは、コンパイラが自動的に通常通りのコードを 使ってくれます。これによって実装の手間が省けています。\n"}),e.add({id:5,href:"/Mjolnir/ja/docs/reference/files/",title:"Files",section:"Reference",content:"[files] #  主にファイル入出力の設定をします。\n例 #  [files] output.path = \u0026#34;data/\u0026#34; output.prefix = \u0026#34;protein1\u0026#34; output.format = \u0026#34;xyz\u0026#34; output.progress_bar = false input.path = \u0026#34;input/\u0026#34; 入力 #  filesテーブルには、outputとinputの2つのテーブルがあります。\nfiles.output #  filesテーブルの中のoutputテーブルには、以下の値を設定します。\n prefix: 文字列型  ファイル名の先頭につく識別子を設定します。出力ファイルは、{prefix}.logのように命名されます。   path: 文字列型  出力ファイルのパスを設定します。そのディレクトリにファイルが出力されます。   format: 文字列型  トラジェクトリファイルのフォーマットを指定します。 粒子ごとに一つの座標情報しか格納できないフォーマットの場合、 {prefix}_positionと{prefix}_velocityの2つのファイルが出力されます。 \u0026quot;xyz\u0026quot;: xyzフォーマットで出力します。 \u0026quot;dcd\u0026quot;: dcdフォーマットで出力します。 \u0026quot;trr\u0026quot;: trrフォーマットで出力します。   progress_bar: 論理値型（デフォルトでtrue）  プログレスバーを表示するかどうかを選択します。 コンソール出力がファイルにリダイレクトされている場合、無条件にfalseになります。    files.input #  filesテーブルの中のinputテーブルには、以下の値を設定します。\n path: 文字列型  入力ファイルを分割する際に、ルートディレクトリを設定します。 例えば、ここに\u0026quot;input\u0026quot;を設定した場合、分割入力の際./input/*.tomlが検索されます。    "}),e.add({id:6,href:"/Mjolnir/ja/docs/tutorial/lennard-jones/",title:"The Lennard-Jones fluid",section:"Tutorial",content:"The Lennard-Jones fluid #  簡単な例として、Lennard-Jonesポテンシャルで相互作用する粒子のシミュレーションをしてみましょう。 あまり時間がかかるシミュレーションにしたくないので、8x8x8の512粒子の系を考えることにします。 特に具体的な何かの原子をシミュレーションしたいというわけではないので、パラメータは適当に決めていきます。\nこのシミュレーションに必要なものは、大まかに\n どのような方法でシミュレーションするか 初期構造 ポテンシャルのパラメータ  です。lennard-jones.tomlというファイルを作って、この順に実際に入力を書いていきましょう。\n[files] and [units] #  具体的な設定を埋めていく前に、細々とした設定を先に済ませておきます。\nまず、出力ファイルの名前とフォーマットを決めましょう。 名前はそのままlennard-jonesに、出力先はカレントディレクトリ、フォーマットはxyzにします。\n[files] output.prefix = \u0026#34;lennard-jones\u0026#34; output.path = \u0026#34;./\u0026#34; output.format = \u0026#34;xyz\u0026#34; 他に何が設定できるかは、Referenceのfilesを見てください。\n今後の入力で使う数値の単位系も決めないといけません。 ここでは、エネルギーの単位はkcal/mol、長さの単位はangstromにします。\n[units] length = \u0026#34;angstrom\u0026#34; energy = \u0026#34;kcal/mol\u0026#34; 他に何が設定できるかは、Referenceのunitsを見てください。\n[simulator] and other general properties #  さて、一般的な部分の設定は済ませたので、いよいよシミュレーションをどのように行うかを設定します。\nまず、今から行うのは普通の分子動力学シミュレーションなので、方法はMolecularDynamicsです。 浮動小数点数の型には倍精度を、境界条件にはPeirodicを適用します。 それと、乱数シードを適当に決めておいてください。\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; precision = \u0026#34;double\u0026#34; boundary_type = \u0026#34;Periodic\u0026#34; seed = 123456789 あとは、時間発展をどうやって、どの程度行うかを決めます。\nここでは、ランジュバン方程式の時間積分法のうち、比較的最近提案されたBAOAB Langevin integratorを使うことにしましょう。 ここでは摩擦係数を粒子ごとに設定することができますが、今回は均質な系にするので、とりあえず全部1にしてしまいましょう。\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; precision = \u0026#34;double\u0026#34; boundary_type = \u0026#34;Periodic\u0026#34; seed = 123456789 delta_t = 0.01 total_step = 100_000 save_step = 100 integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  {index = 0, gamma = 1.00},  {index = 1, gamma = 1.00},  {index = 2, gamma = 1.00},  # ...  {index = 511, gamma = 1.00}, ] ちょっと大変ですが、エディタのマクロを使ったり、適当なスクリプトを書いてしまえばすぐです。\n他に何が設定できるかは、Referenceのsimulatorを見てください。\n[[systems]] #  続いて粒子の初期構造と、系全体のパラメータを設定しましょう。\nまず、ランジュバン動力学で使う系の温度と、周期境界条件で使う境界の大きさを指定します。\n[[systems]] attributes.temperature = 300.0 # K boundary_shape.lower = [ 0.0, 0.0, 0.0] boundary_shape.upper = [16.0, 16.0, 16.0] 簡単に済ませたいので、粒子は格子状に並べることにします。 初期構造であまりにもエネルギーが高くなっては困るので、粒子の半径を1Åにして、距離2Åで並べていくことにしましょうか。\n[[systems]] attributes.temperature = 300.0 # K boundary_shape.lower = [ 0.0, 0.0, 0.0] boundary_shape.upper = [16.0, 16.0, 16.0] particles = [  {mass = 1.0, position = [ 1.000, 1.000, 1.000]},  {mass = 1.0, position = [ 3.000, 1.000, 1.000]},  {mass = 1.0, position = [ 5.000, 1.000, 1.000]},  {mass = 1.0, position = [ 7.000, 1.000, 1.000]},  {mass = 1.0, position = [ 9.000, 1.000, 1.000]},  {mass = 1.0, position = [11.000, 1.000, 1.000]},  {mass = 1.0, position = [13.000, 1.000, 1.000]},  {mass = 1.0, position = [15.000, 1.000, 1.000]},   {mass = 1.0, position = [ 1.000, 3.000, 1.000]},  {mass = 1.0, position = [ 3.000, 3.000, 1.000]},  {mass = 1.0, position = [ 5.000, 3.000, 1.000]},  {mass = 1.0, position = [ 7.000, 3.000, 1.000]},  {mass = 1.0, position = [ 9.000, 3.000, 1.000]},  {mass = 1.0, position = [11.000, 3.000, 1.000]},  {mass = 1.0, position = [13.000, 3.000, 1.000]},  {mass = 1.0, position = [15.000, 3.000, 1.000]},  # 続く... ] 他に何が設定できるかは、ReferenceのSystemsを見てください。\n[[forcefields]] #  最後に、力場のパラメータを設定して終わりです。\nLennard-Jonesは非局所的な相互作用であり、かつ外力ではないので、globalな相互作用に属します。 まずは[[forcefields.global]]を定義しましょう。 そしてそこに、二体間相互作用であることと、ポテンシャル関数としてLennard-Jonesを使うことを指定します。\n[[forcefields]] [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJones\u0026#34; 続いて、計算の効率化のための空間分割法について設定します。 今回は、系が小さいのでCell Listでは速度が出ないかも知れません。 とりあえず、単純にリストを構築して一定時間使いまわすだけのVerletListにしておきます。\n近距離ペアリストによる高速化では、カットオフ距離からマージンを取って少し離れた粒子までをリストに入れておき、粒子が移動した距離に応じてマージンを減らして、リストを再構築するまでの時間を自動的に計算します。 そのために、このマージンをどの程度にするかも決めなければなりません。 相互作用と系がどの程度密かに依存しますが、今回は適当に決めます。 これは計算結果に影響しない（計算が終わるまでの時間には影響します）ので、適当でも構いません。\n[[forcefields]] [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJones\u0026#34; spatial_partition.type = \u0026#34;VerletList\u0026#34; spatial_partition.margin = 0.25 最後に、各粒子のパラメータを設定していきます。 二つの粒子の間にかかるポテンシャルのパラメータは、Lorentz-Berthelot則によって決まります。\n[[forcefields]] [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJones\u0026#34; spatial_partition.type = \u0026#34;VerletList\u0026#34; spatial_partition.margin = 0.25 parameters = [  {index = 0, sigma = 2.0, epsilon = 1.0},  {index = 1, sigma = 2.0, epsilon = 1.0},  {index = 2, sigma = 2.0, epsilon = 1.0},  # ...  {index = 511, sigma = 2.0, epsilon = 1.0}, ] 他に何が設定できるかは、ReferenceのForceFieldsを見てください。\nSimulation #  お疲れ様でした！　これで入力ファイルは全部です。 このファイルをコンパイルしたmjolnirに渡せば、以下のようなログが出て、計算が始まります。 コンピュータによりますが、数分で終わるはずです。\n$ ./bin/mjolnir lennard-jones.toml reading input file... -- reading and parsing toml file `lennard-jones.toml` ... successfully parsed. -- the log file is `./lennard-jones.log` -- mjolnir version v1.22.0 -- compiled using /usr/bin/g++-10 -- input_path is ./ -- expanding include files ... -- done. -- precision is double -- Boundary Condition is Periodic. The shape is cuboid. -- execute on single core -- energy unit is [kcal/mol] -- length unit is [angstrom] -- Integrator is BAOABLangevin. -- Simulator type is MolecularDynamics. -- total step is 100000 -- save step is 100 -- checkpoint step is 100 -- reading 0th system ... -- 512 particles are found. -- output file prefix is `./lennard-jones` -- output xyz format. -- GlobalForceField (x1) found -- reading 0th [[forcefields.global]] -- Pair interaction found. -- -- potential function is Lennard-Jones. -- -- Spatial Partition is VerletList with relative margin = 0.25 -- No `ignore.group` is provided. All the groups are taken into account. -- No `ignore.molecule` is provided. All the molecules are taken into account. -- seed is 123456789 done. initializing simulator... -- generating velocity with T = 300... -- done. done. start running simulation 14.1%|███████ | 56.0 seconds remaining 計算が終われば、以下のようなファイルが出力されているはずです。\n$ ls lennard-jones* lennard-jones.toml lennard-jones.log lennard-jones_velocity.xyz lennard-jones_system.msg lennard-jones_rng.msg lennard-jones_position.xyz lennard-jones.ene .msgファイルはシミュレーションを再開するためのリスタート用ファイルで、そのフォーマットはMsgPackです。\n.eneファイルはエネルギーなどの値が単純なテキストベースで書かれており、gnuplotなどで簡単にプロットすることができます。\n$ head lennard-jones.ene # unit of length : angstrom, unit of energy : kcal/mol # timestep GlobalPairLennardJones kinetic_energy attribute:temperature 0 -1704.786330 453.454993 300.000000 100 -2579.996798 812.198804 300.000000 200 -2787.935537 554.446648 300.000000 300 -2909.224864 473.619251 300.000000 400 -2913.189150 453.464065 300.000000 500 -2964.234777 463.400579 300.000000 600 -2988.270454 462.704726 300.000000 700 -2960.111833 458.723132 300.000000 lennard-jones_position.xyzが位置のトラジェクトリです。 これをVMDなどに渡すことで、トラジェクトリを見ることができます。\nConclusion #  このチュートリアルは以上です。\n入力ファイルの書き方を少し冗長だと思った人もいるかもしれません。 しかし、必要なパラメータを全て陽に指定できるということは、逆に簡単に好きなパラメータでシミュレーションを走らせることができるということでもあります。 このチュートリアルも、興味がある人はパラメータを一部変えてみて、例えば一つの粒子だけをとんでもなく大きくしたりして、何が起きるか観察して楽しんでみてください。\n"}),e.add({id:7,href:"/Mjolnir/ja/docs/tutorial/polymer-model/",title:"A simple polymer model",section:"Tutorial",content:"A simple polymer model #  前回に続いて、今度は局所的な相互作用の設定方法を、簡単なポリマーのシミュレーションを通して説明します。\n今回は100個の粒子を調和振動子ポテンシャルで繋げてみます。 簡単のため、初めは繋がっていない粒子に非局所的な相互作用はないとします。\n[files] and [units] #  前回と同様、細々とした設定を先に済ませてしまいましょう。\nまずは、出力ファイルの名前とフォーマットを決めます。\n[files] output.prefix = \u0026#34;polymer-model\u0026#34; output.path = \u0026#34;./\u0026#34; output.format = \u0026#34;xyz\u0026#34; 他に何が設定できるかは、Referenceのfilesを見てください。\n単位は、kcal/molとangstromにします。\n[units] length = \u0026#34;angstrom\u0026#34; energy = \u0026#34;kcal/mol\u0026#34; 他に何が設定できるかは、Referenceのunitsを見てください。\n[simulator] #  ここもほぼ前回と同じです。\nですが、今回は全ての粒子が繋がっていて、遠くに離れていく心配がないので、周期境界条件をなくしてみましょう。\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; precision = \u0026#34;double\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; # No periodic boundary seed = 123456789 delta_t = 0.01 total_step = 1_000_000 save_step = 1_000 integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  {index = 0, gamma = 1.00},  {index = 1, gamma = 1.00},  {index = 2, gamma = 1.00},  # ...  {index = 99, gamma = 1.00}, ] 他に何が設定できるかは、ReferenceのSimulatorを見てください。\n[[systems]] #  前回と違い周期境界条件を適用しないことにしたので、boundary_shapeを指定する必要はありません。\n今回は、最初は伸び切った直線のコンフォメーションからシミュレーションを始めます。\n[[systems]] attributes.temperature = 300.0 # K particles = [  {mass = 1.0, position = [ 0.000, 0.000, 0.000]},  {mass = 1.0, position = [ 1.000, 0.000, 0.000]},  {mass = 1.0, position = [ 2.000, 0.000, 0.000]},  {mass = 1.0, position = [ 3.000, 0.000, 0.000]},  {mass = 1.0, position = [ 4.000, 0.000, 0.000]},  {mass = 1.0, position = [ 5.000, 0.000, 0.000]},  {mass = 1.0, position = [ 6.000, 0.000, 0.000]},  {mass = 1.0, position = [ 7.000, 0.000, 0.000]},  {mass = 1.0, position = [ 8.000, 0.000, 0.000]},  # 続く...  {mass = 1.0, position = [99.000, 0.000, 0.000]}, ] 他に何が設定できるかは、ReferenceのSystemsを見てください。\n[[forcefields]] #  最後に、力場のパラメータを設定します。\n今回は結合長ポテンシャルを設定します。 これは局所的な（最初に指定したペアの間のみで働く）相互作用なので、定義するのは[[forcefields.local]]です。\n相互作用の種類は結合長なのでBondLength、ポテンシャル関数は調和振動子なのでHarmonicです。\n[[forcefields]] [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;bond\u0026#34; topologyというのは、あとで説明しますが、局所的な相互作用と非局所的な相互作用の間をうまく取り持つためのラベルです。 今回は必要ないので、適当な名前で埋めておきます。\nさて、では隣り合う粒子の間にポテンシャルを適用していきましょう。\n[[forcefields]] [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [ 0, 1], v0 = 1.0, k = 10.0},  {indices = [ 1, 2], v0 = 1.0, k = 10.0},  {indices = [ 2, 3], v0 = 1.0, k = 10.0},  # ...  {indices = [98,99], v0 = 1.0, k = 10.0}, ] これで力場のパラメータは全部です。\n他に何が設定できるかは、ReferenceのForceFieldsを見てください。\nSimulation #  お疲れ様でした！　これで入力ファイルは全部です。 このファイルをコンパイルしたmjolnirに渡せば、以下のようなログが出て、計算が始まります。\n前回より粒子数が少ないので、すぐに終わるはずです。\n$ ./bin/mjolnir polymer-model.toml reading input file... -- reading and parsing toml file `polymer-model.toml` ... successfully parsed. -- the log file is `./polymer-model.log` -- mjolnir version v1.22.0-dev (06d5ede6) -- compiled using /usr/bin/g++-10 -- input_path is ./ -- expanding include files ... -- done. -- precision is double -- Boundary Condition is Unlimited -- execute on single core -- energy unit is [kcal/mol] -- length unit is [angstrom] -- Integrator is BAOABLangevin. -- Simulator type is MolecularDynamics. -- total step is 1000000 -- save step is 1000 -- checkpoint step is 1000 -- reading 0th system ... -- 100 particles are found. -- output file prefix is `./polymer-model` -- output xyz format. -- LocalForceField (x1) found -- reading 0th [[forcefields.local]] -- Bond Length interaction found. -- -- potential function is Harmonic. -- -- 99 interactions are found. -- seed is 123456789 done. initializing simulator... -- generating velocity with T = 300... -- done. done. start running simulation 8.2%|████ | 10.5 seconds remaining 計算が終われば、以下のようなファイルが出力されているはずです。\n$ ls polymer-model* polymer-model.toml polymer-model.ene polymer-model.log polymer-model_rng.msg polymer-model_system.msg polymer-model_position.xyz polymer-model_velocity.xyz .msgファイルはシミュレーションを再開するためのリスタート用ファイルで、そのフォーマットはMsgPackです。\n.eneファイルはエネルギーなどの値が単純なテキストベースで書かれており、gnuplotなどで簡単にプロットすることができます。\n$ head polymer-model.ene # unit of length : angstrom, unit of energy : kcal/mol # timestep BondLength:Harmonic kinetic_energy attribute:temperature 0 0.000000 96.956625 300.000000 1000 56.910239 86.124451 300.000000 2000 51.497857 85.960034 300.000000 3000 44.394914 90.433666 300.000000 4000 50.774066 89.091169 300.000000 5000 46.749105 104.594276 300.000000 6000 34.130104 86.045558 300.000000 7000 39.505721 84.893861 300.000000 polymer-model_position.xyzが位置のトラジェクトリです。 これをVMDなどに渡すことで、トラジェクトリを見ることができます。\nConclusion #  このチュートリアルは以上です。\nBondLengthを設定する二つの粒子の番号を直接指定しました。 これはなにも連続した二粒子である必要はなく、好きな粒子のペアに相互作用をかけることができます。 最初と最後の粒子を繋いで環状にすることも、一つ飛ばしで繋いで角度をつけることもできます。\n局所的な相互作用は他にも、結合角、二面角などが知られています。 Mjolnirはこれらを同様の形でサポートしているので、興味のある組み合わせを試してみてください。\nそれらの設定方法は、ReferenceのLocalForceFieldを見てください。\n"}),e.add({id:8,href:"/Mjolnir/ja/docs/reference/units/",title:"Units",section:"Reference",content:"[units] #  単位系を設定します。\n[[forcefields]]のエネルギーのパラメータや[[systems]]での粒子の位置など、ファイルから入力される数値は、この設定に従って使われます。\n例 #  [units] length = \u0026#34;angstrom\u0026#34; energy = \u0026#34;kcal/mol\u0026#34; units #  以下のフィールドがあります。\n energy: 文字列型  \u0026quot;kcal/mol\u0026quot; \u0026quot;kJ/mol\u0026quot;   length: 文字列型  \u0026quot;nm\u0026quot; \u0026quot;angstrom\u0026quot;    質量の単位はAMU、電荷の単位は電気素量で固定されています。 また、角度の単位は常にラジアンです。 現在、これらは変更することはできません。\n時間の単位系はここで決めた単位系（と質量の単位）から計算されます。 例としては、\u0026quot;kcal/mol\u0026quot;と\u0026quot;angstrom\u0026quot;を選んだ場合、1単位時間は約49fsになります。  "}),e.add({id:9,href:"/Mjolnir/ja/docs/reference/simulators/",title:"Simulators",section:"Reference",content:"[simulator] #  [simulator]テーブルでは、シミュレーション全体の設定と時間積分のアルゴリズムを設定します。\n全シミュレータに共通して、シミュレーションに用いる浮動小数点数の精度と、境界条件の種類を指定する必要があります。\nまた、並列化を行う際もこの時点で設定を行います。\nInput Reference #  Common Part #  以下のフィールドは全てのシミュレータに共通です。\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; boundary_type = \u0026#34;Periodic\u0026#34; precision = \u0026#34;double\u0026#34; parallelism = \u0026#34;OpenMP\u0026#34; # optional  type: 文字列型  シミュレータの種類を指定します。例えば、普通のシミュレーションの他に、焼きなまし法やエネルギー最小化などが選べます。 選択できるシミュレータは\u0026quot;Available Simulators\u0026quot;を参照してください。   boundary_type: 文字列型  境界条件の種類を選択します。具体的な形状はSystemで指定します。 \u0026quot;Unlimited\u0026quot;: 境界条件を設定しません。シミュレーションボックスは無限大の大きさになります。 \u0026quot;Periodic\u0026quot;: 直方体型の周期境界条件を指定します。 \u0026quot;PeriodicCuboid\u0026quot;: 直方体型の周期境界条件を指定します。上と同じです。   precition: 文字列型  シミュレーションに用いる浮動小数点数型の種類を指定します。 \u0026quot;float\u0026quot;: 32bit浮動小数点数を使用します。 \u0026quot;double\u0026quot;: 64bit浮動小数点数を使用します。   parallelism: 文字列型(省略可)  並列化する際の実装を選択します。省略した際は、シングルコアで実行されます。 \u0026quot;OpenMP\u0026quot;: OpenMPを使った実装を使用します。 \u0026quot;sequencial\u0026quot;: 並列化を行いません。省略した場合はこれが選択されます。   forcefield: テーブル型 (省略可)  特殊な場合のためのフィールドです。 使用例は、MultipleBasinForceFieldを参照してください。    Available Simulators #   MolecularDynamics  ごく通常の分子動力学シミュレーションを行います。   SimulatedAnnealing  焼きなまし法を行います。   SteepestDescent  最急降下法によってエネルギー極小の構造を探します。   SwitchingForceField  指定した時刻に力場を変更するシミュレーションを行います。   EnergyCalculation  与えられたトラジェクトリの各フレームでのエネルギーを、指定された力場で計算します。    "}),e.add({id:10,href:"/Mjolnir/ja/docs/reference/integrators/",title:"Integrators",section:"Reference",content:"Integrator #  Integratorは、時間積分のアルゴリズムを意味します。\n以下のアルゴリズムを選択できます。\nG-JF Langevin #  ランジュバン方程式に従い、温度・体積・粒子数一定のシミュレーションを行います。\n以下の論文で提案された手法です。\n Niels Grønbech-Jensen \u0026amp; Oded Farago, (2013) Mol.Phys. 111:8, 983-991  BAOABLangevin #  ランジュバン方程式に従い、温度・体積・粒子数一定のシミュレーションを行います。\n以下の論文で提案された手法です。\n Benedict Leimkuhler and Charles Matthews. Appl. Math. Res. Exp. (2013) 2013:1, pp. 34-56 Benedict Leimkuhler and Charles Matthews. J. Chem. Phys. (2013) 138:17, 174102  OpenMMで推奨されているアルゴリズムです。\ng-BAOABLangevin #  ランジュバン方程式に従い、温度・体積・粒子数一定のシミュレーションを行います。\nBAOABLangevinと同等ですが、拘束条件を扱うことができます。\n以下の論文で提案された手法です。\n Leimkuhler B, Matthews C. Proc. R. Soc. A. (2016)  GFWNPTLangevin #  ランジュバン方程式に従い、温度・圧力・粒子数一定のシミュレーションを行います。\n以下の論文で提案された手法です。\n Xingyu Gao, Jun Fang, and Han Wang. J. Chem. Phys. (2016) 144, 124113  UnderdampedLangevin #  ランジュバン方程式に従い、温度・体積・粒子数一定のシミュレーションを行います。\n以下の論文で紹介された手法です。\n J. D. Honeycutt and D. Thirumalai, (1992) Biopolymers Z. Guo and D. Thirumalai, (1995) Biopolymers.  また、以下のシミュレータで使用されている手法です。\n H. Kenzaki et al., (2011) JCTC.  VelocityVerlet #  ニュートンの運動方程式に従い、エネルギー・体積・粒子数一定のシミュレーションを行います。\n"}),e.add({id:11,href:"/Mjolnir/ja/docs/reference/system/",title:"System",section:"Reference",content:"System #  系に含まれる粒子や、系の境界条件、系全体のパラメータなどを設定します。\n複数のシミュレーションボックスを持つシミュレーションのためにテーブルの配列として 定義されていますが、通常のシミュレーションでは一つしか定義しません。\n例 #  [[systems]] attributes.temperature = 300.0 boundary_shape.lower = [ 0.0, 0.0, 0.0] # lower limit of the boundary boundary_shape.upper = [100.0, 100.0, 100.0] # upper limit of the boundary particles = [  {m= 1.0, pos=[ 1.000, 2.000, -1.000], vel=[ 0.100,-0.200, 0.300], name=\u0026#34;CA\u0026#34;, group=\u0026#34;A\u0026#34;},  # ... ] 入力 #   boundary_shape: テーブル型  境界の具体的な大きさを設定します。 Unlimitedな境界条件の場合、省略可能です。   attributes: テーブル型  系全体に適用されるパラメータを設定します。   particles: テーブルの配列型  系に含まれる粒子のパラメータと、初期条件を設定します。 mまたはmass: 浮動小数点数型 posまたはposition: 浮動小数点数の配列型（要素数は3） velまたはvelocity: 浮動小数点数の配列型（要素数は3、省略可能） name: 文字列型（省略可能） group: 文字列型（省略可能）    \u0026quot;Periodic\u0026quot;境界条件でのboundary_shape #  境界条件がPeriodicCuboidの場合、直方体の各座標の最大と最小の座標を取る頂点を設定します。\n lower: 浮動小数点の配列型  各座標で最小の座標を取る頂点の位置を指定します。   upper: 浮動小数点の配列型  各座標で最大の座標を取る頂点の位置を指定します。    boundary_shape = {lower = [0.0, 0.0, 0.0], upper = [10.0, 10.0, 10.0]} または、\nboundary_shape.lower = [ 0.0, 0.0, 0.0] boundary_shape.upper = [100.0, 100.0, 100.0] attribute #  系全体に適用されるパラメータを指定します。 力場やシミュレータによって必要なパラメータが変化します。 現在、要求される変数は以下のどれかです。\n temperature: 浮動小数点数型  系の参照温度を指定します。温度一定のシミュレーションを行う際は指定しておく必要があります。   ionic_strength: 浮動小数点数型  系のイオン強度を指定します。単位は[mol/L]です。 イオン粒子が陽に含まれない系で静電相互作用を使用する際に必要になることがあります。    particles #  系の粒子のパラメータと、初期条件を指定します。 一つの粒子に対して一つのテーブルが割り当てられ、質量、位置、速度、名前、グループ名を指定します。\nparticles = [  {mass= 1.0, position=[ 1.000, 2.000, -1.000], velocity=[ 0.100,-0.200, 0.300], name=\u0026#34;CA\u0026#34;, group=\u0026#34;A\u0026#34;},  # 短縮形  {m= 1.0, pos=[ 1.000, 2.000, -1.000], vel=[ 0.100,-0.200, 0.300], name=\u0026#34;CA\u0026#34;, group=\u0026#34;A\u0026#34;},  # ... ] 初期速度を指定しなかった場合、Maxwell-Boltzmann分布に従って指定した温度での 初期速度がSimulatorで設定したseedを使ってランダムに生成されます。\nそのため、省略した場合はsystem.attributes.temperatureの値を設定していることが 要求されます。\nparticles = [  {m= 1.0, pos=[ 1.000, 2.000, -1.000], name=\u0026#34;CA\u0026#34;, group=\u0026#34;A\u0026#34;},  # ... ] 他のシミュレーションの最終構造をインポートする #  Mjolnirは、ファイル出力時にMsgPackでSystemの全状態をエンコードして出力します。 このファイルを指定することで、前回のシミュレーションの続きからの再開や、途中で計算が止まってしまった時にすぐにやり直すことができます。\n[[systems]] file_name = \u0026#34;restart.msg\u0026#34; "}),e.add({id:12,href:"/Mjolnir/ja/docs/reference/forcefields/",title:"ForceFields",section:"Reference",content:"[[forcefields]] #  用いる力場を設定します。 パラメータの単位は[units]での設定に準じます。\n複数の力場を扱うシミュレーションのために、テーブルの配列として定義されています。 通常のシミュレーションでは、一つしか定義されません。\nenv #  [[forcefields]]内では、特殊な値envを使用することができます。\nenvはテーブルで、ここに値を定義することで、同じ相互作用テーブルの中で値を参照することができます。\n[[forcefields.local]] env.pi = 3.1416 # これによって3.1416の代わりに文字列\u0026#34;pi\u0026#34;を使用できるようになります。 parameters = [  {indices = [0, 1], k = 100.0, v0 = \u0026#34;pi\u0026#34;},  {indices = [1, 2], k = 100.0, v0 = \u0026#34;pi\u0026#34;},  {indices = [2, 3], k = 100.0, v0 = \u0026#34;pi\u0026#34;}, ] この機能はファイルのインクルードと組み合わせて使用することができます。\nLocalForceFiled #  決まった粒子の間のみにかかる相互作用です。結合長、結合角、二面角などが該当します。\nGlobalForceFiled #  対応する粒子の全てのペアにかかる相互作用です。ペア相互作用、例えば静電相互作用などが該当します。\nExternalForceFiled #  外力による相互作用です。空間中の点に粒子を束縛する相互作用や、壁を設定する相互作用が該当します。\nConstraintForceField #  拘束条件です。特定の粒子間の距離を一定に保ちます。\nMultipleBasinForceField #  特殊なメタ力場で、複数の力場をスムースに結合することができます。\nHybridForceField #  二つの力場の線形結合であらわされるメタ力場です。\n"}),e.add({id:13,href:"/Mjolnir/ja/docs/reference/integrators/BAOABLangevinIntegrator/",title:"BAOABLangevin",section:"Integrators",content:"BAOABLangevin #  ランジュバン方程式に従い、温度・体積・粒子数 (NVT) 一定のシミュレーションを行います。\n  \\[m\\frac{d^2 \\bold{r}}{dt^2} = \\bold{f}(\\bold{r}) - m\\gamma\\bold{v} \u0026#43; \\beta(t)\\]  以下の論文で提案された手法です。\n Benedict Leimkuhler and Charles Matthews. Appl. Math. Res. Exp. (2013) 2013:1, pp. 34-56 Benedict Leimkuhler and Charles Matthews. J. Chem. Phys. (2013) 138:17, 174102  例 #  [simulator] integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  {index = 0, gamma = 1.0},  {index = 1, gamma = 1.0},  # ... ] 入力 #  delta_tなどの他のパラメータはSimulatorで設定します。\n type: 文字列型  Integratorの種類を指定します。\u0026quot;BAOABLangevin\u0026quot;です。   gammas: テーブルの配列型  粒子の摩擦係数 \\(\\gamma_i\\)  を指定します。   remove: テーブル型 (optional)  translation: 論理値型  trueの場合、毎ステップ、系全体の並進速度成分を取り除きます。   rotation: 論理値型  trueの場合、毎ステップ、系全体の回転速度成分を取り除きます。   rescale: 論理値型  trueになっていた場合、全体の速度ベクトルをリスケールすることで速度を減算した分の運動エネルギーを補填します。   省略した場合、全てfalseになります。    "}),e.add({id:14,href:"/Mjolnir/ja/docs/reference/forcefields/local/",title:"Local",section:"ForceFields",content:"LocalForceField #  LocalForceFieldでは、結合長や結合角、二面角など特定の粒子の間のみに働く相互作用を設定します。\nBondLengthInteraction #  BondLength相互作用は、その名の通り結合長にかかる相互作用です。\nBondAngleInteraction #  BondAngle相互作用は、3つの粒子間に形成される角度に応じてかかる相互作用です。 粒子i, j, kを指定すると、ベクトルr_jiとr_jkのなす角度にかかります。\nDihedralAngleInteraction #  DihedralAngle相互作用は、4つの粒子間に定義される二面角に応じてかかる相互作用です。 粒子i, j, k, lを指定すると、i, j, kがなす面とj, k, lのなす面のなす角に対してかかります。\nContactInteraction #  Contact相互作用は、2つの粒子間の距離に応じてかかる相互作用です。\nなので基本的に結合長相互作用と同じ形をしていますが、結合長と違って力がかからなくなる可能性を考慮しています。 内部にポテンシャルのリストを作り、それを管理することで力のかかっていないポテンシャルをスキップすることができます。\nDummyInteraction #  Dummy相互作用は、何もしない相互作用です。ただし、設定したトポロジーは適用されます。\n粒子i, jを指定すると、その粒子間に力をかけることなくトポロジーを設定することができます。\nトポロジーの効果については、Topologyを参照して下さい。\n3SPN2BaseStacking #  3SPN2BaseStacking相互作用は、3SPN2系統の力場で用いられるスタッキング相互作用です。\n"}),e.add({id:15,href:"/Mjolnir/ja/docs/reference/simulators/MolecularDynamicsSimulator/",title:"MolecularDynamics",section:"Simulators",content:"MolecularDynamics #  通常の分子動力学シミュレーションを行うシミュレータです。\nsystemを一つ、forcefieldを一つ要求します。\nExample #  [simulator] type = \u0026#34;MolecularDynamics\u0026#34; boundary_type = \u0026#34;PeriodicCuboid\u0026#34; precision = \u0026#34;double\u0026#34; parallelism = \u0026#34;OpenMP\u0026#34; # optional seed = 12345 delta_t = 0.1 total_step = 50_000 save_step = 100 integrator.type = \u0026#34;VelocityVerlet\u0026#34; Input Reference #   type: 文字列型  シミュレータの種類を指定します。このシミュレータを使う場合、\u0026quot;MolecularDynamics\u0026quot;です。   boundary_type: 文字列型  境界条件の種類を指定します。具体的な大きさは[[systems]]で指定します。 \u0026quot;Unlimited\u0026quot;: 境界条件を設定しません。シミュレーションボックスは無限大の大きさになります。 \u0026quot;PeriodicCuboid\u0026quot;: 直方体型の周期境界条件を指定します。   precision: 文字列型  シミュレーションに用いる浮動小数点数型の種類を指定します。 \u0026quot;float\u0026quot;: 32bit浮動小数点数を使用します。 \u0026quot;double\u0026quot;: 64bit浮動小数点数を使用します。   parallelism: 文字列型(省略可。デフォルトで並列化なし)  並列化する際の実装を選択します。 \u0026quot;OpenMP\u0026quot;: OpenMPを使った実装を使用します。 \u0026quot;sequencial\u0026quot;: 並列化を行いません。省略した場合はこれが選択されます。   seed: 整数型  乱数生成器の初期化に用いるシードを設定します。   delta_t: 浮動小数点数型  シミュレーションの時間刻みを指定します。 時間の単位は[units]で指定した単位系に依存します。   total_step: 整数型  実行するステップ数を指定します。   save_step: 整数型  何ステップおきに状態を出力するか指定します。   integrator: テーブル型  時間積分の方法を指定します。積分方法によって必要なパラメータが異なります。 以下のアルゴリズムが使用可能です。 \u0026ldquo;BAOABLangevin\u0026rdquo; \u0026ldquo;g-BAOABLangevin\u0026rdquo; \u0026ldquo;UnderdampedLangevin\u0026rdquo; \u0026ldquo;VelocityVerlet\u0026rdquo; 参考：integrators.    "}),e.add({id:16,href:"/Mjolnir/ja/docs/reference/integrators/gBAOABLangevinIntegrator/",title:"g-BAOABLangevin",section:"Integrators",content:"g-BAOABLangevin #  ランジュバン方程式に従い、温度・体積・粒子数 (NVT) 一定のシミュレーションを行います。\nBAOABLangevinと異なり、結合長に対する拘束条件を取り扱うことができます。\n以下の論文で提案された手法です。\n Leimkuhler B, Matthews C. Proc. R. Soc. A. (2016)  例 #  [simulator] # ... integrator.type = \u0026#34;g-BAOABLangevin\u0026#34; integrator.gammas = [  {index = 0, gamma = 1.0},  {index = 1, gamma = 1.0},  # ... ] 入力 #  delta_tなどの他のパラメータはSimulatorで設定します。\n type: 文字列型  Integratorの種類を指定します。\u0026quot;g-BAOABLangevin\u0026quot;です。   gammas: テーブルの配列型  粒子の摩擦係数   \\(\\gamma_i\\)  を指定します。   remove: テーブル型 (optional)  translation: 論理値型  trueの場合、毎ステップ、系全体の並進速度成分を取り除きます。   rotation: 論理値型  trueの場合、毎ステップ、系全体の回転速度成分を取り除きます。   rescale: 論理値型  trueになっていた場合、全体の速度ベクトルをリスケールすることで速度を減算した分の運動エネルギーを補填します。   省略した場合、全てfalseになります。    Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:17,href:"/Mjolnir/ja/docs/reference/forcefields/global/",title:"Global",section:"ForceFields",content:"GlobalForceField #  GlobalForceFieldは相互作用に参加する粒子全ての間にかかる力です。\nGlobalPair #  2粒子間の距離に依存する相互作用です。\n3SPN2BaseBase #  3SPN2粗視化DNAモデルで用いられる相互作用です。\nProteinDNANonSpecific #  水素結合の粗視化モデルです。\n相互作用間で共通した部分 #  全ての[[forcefields.global]]テーブルは、相互作用ペアから除外する条件を記述するignoreと、近接リストを作るアルゴリズムを記述するspatial_partitionを共通して持ちます。\nignore #  除外する条件としては、3種類の条件を指定できます。\nまずparticles_withinでは、Topology上で結合を辿って見つかるペアの相互作用を除外することができます。\n続いてgroupでは、Systemで各粒子に定義したgroupに基づいて、group間・group内での相互作用を一気に除外することができます。\n最後にmoleculeは、bondを伝ってたどり着ける粒子の集合をmoleculeとし、molecule間・molecule内の相互作用を一気に除外することができます。\nこの設定は全て省略可能です。省略した場合、どのペアも無視せず、全ての相互作用を計算します。\n ignore.particles_within: テーブル型（省略可能）  一定個数の結合を辿って見つかる範囲にある粒子のペアを除外します。 このテーブルで定義されているキーがたどる結合の名前で、値はたどる最大回数です。 例えば、ignore.particles_within.bond = 3だとbondという名前をTopology上で3回までたどって見つかる粒子のペアを除外します。 ignores particles that are connected via 1, 2, or 3 consecutive bond connections.   ignore.group: テーブル型（省略可能）  group内・間のペアを除外します。 intra: 文字列の配列型  グループ内のペアを除外します。適用するグループのリストを渡します。   inter: 文字列の配列の配列型  グループ間のペアを除外します。適用するグループのリストを渡します。   あとで例が示されます。   ignore.molecule: 文字列型（省略可能）  molecule間・内の相互作用を除外します。 \u0026quot;Nothing\u0026quot;: 何も除外しません。全てのペアを計算します。 \u0026quot;Self\u0026quot;: 同じmoleculeにあるペアは除外します。 \u0026quot;Others\u0026quot;: 異なるmoleculeにあるペアは除外します。    以下のような系があるとします。\n[[systems]] particles = [  {... group = \u0026#34;A\u0026#34;}, # particle 0  {... group = \u0026#34;A\u0026#34;}, # 1  {... group = \u0026#34;A\u0026#34;}, # 2   {... group = \u0026#34;B\u0026#34;}, # particle 3  {... group = \u0026#34;B\u0026#34;}, # 4  {... group = \u0026#34;B\u0026#34;}, # 5   {... group = \u0026#34;C\u0026#34;}, # particle 6  {... group = \u0026#34;C\u0026#34;}, # 7  {... group = \u0026#34;C\u0026#34;}, # 8 ] 以下の相互作用は、\n[[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; ignore.group.intra = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] 粒子0と1、0と2、1と2は、同じグループに属しているペアなので除外されますが、0と3、0と6、3と6の間の相互作用は、異なるグループに属している相互作用なので、除外れず計算されます。\nまた、以下の場合は、\n[[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; ignore.group.inter = [[\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;], [\u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;]] 粒子0と3, 0と4, 0と5はグループAとBの間のペアなので、また3と6, 3と7, 3と8はグループAとCの間のペアなので除外されますが、0と1、3と4、3と6は計算されます。\nspatial_partition #  近接リストを生成するためのアルゴリズムを指定します。\n type: 文字列型  アルゴリズムの種類を決めます。以下が使用可能です。 \u0026quot;CellList\u0026quot;: セルリストから近接リストを作ります。 \u0026quot;RTree\u0026quot;: R木を構築し、近接リストを作ります。 \u0026quot;VerletList\u0026quot;: 全ペアを見て近接リストを作ります。相互作用に関わる粒子の数が十分少ない場合は拘束なことがあります。   margin: 浮動小数点数型  近接リストで用いるマージンの長さです。カットオフ長との相対値です。 これは実行効率には影響しますが、精度には影響しません。最適な値はポテンシャルと系に依存します。    "}),e.add({id:18,href:"/Mjolnir/ja/docs/reference/simulators/SimulatedAnnealingSimulator/",title:"SimulatedAnnealing",section:"Simulators",content:"SimulatedAnnealing #  焼きなまし（Simulated Annealing）法のためのシミュレータです。\nsystemを一つ、forcefieldを一つ要求します。\nExample #  [simulator] type = \u0026#34;SimulatedAnnealing\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; parallelism = \u0026#34;OpenMP\u0026#34; # optional delta_t = 0.1 total_step = 50_000 save_step = 100 each_step = 100 schedule.type = \u0026#34;linear\u0026#34; schedule.begin = 300.0 # temperature in [K] schedule.end = 150.0 # temperature in [K]  integrator.type = \u0026#34;UnderdampedLangevin\u0026#34; integrator.parameters = [  # ... ] Input Reference #   type: 文字列型  シミュレータの種類を指定します。このシミュレータを使う場合、\u0026quot;SimulatedAnnealing\u0026quot;です。   boundary_type: 文字列型  境界条件の種類を指定します。具体的な大きさは[[systems]]で指定します。 \u0026quot;Unlimited\u0026quot;: 境界条件を設定しません。シミュレーションボックスは無限大の大きさになります。 \u0026quot;PeriodicCuboid\u0026quot;: 直方体型の周期境界条件を指定します。   precision: 文字列型  シミュレーションに用いる浮動小数点数型の種類を指定します。 \u0026quot;float\u0026quot;: 32bit浮動小数点数を使用します。 \u0026quot;double\u0026quot;: 64bit浮動小数点数を使用します。   parallelism: 文字列型(省略可)  並列化する際の実装を選択します。 \u0026quot;OpenMP\u0026quot;: OpenMPを使った実装を使用します。 \u0026quot;sequencial\u0026quot;: 並列化を行いません。省略した場合はこれが選択されます。   seed: 整数型  乱数生成器の初期化に用いるシードを設定します。   delta_t: 浮動小数点数型  シミュレーションの時間刻みを指定します。 時間の単位は[units]で指定した単位系に依存します。   total_step: 整数型  実行するステップ数を指定します。   save_step: 整数型  何ステップおきに状態を出力するか指定します。   each_step: 整数型  何ステップおきに温度を変更するか指定します。   schedule: テーブル型  どのように温度を変更するか指定します。   integrator: テーブル型  時間積分の方法を指定します。積分方法によって必要なパラメータが異なります。 \u0026ldquo;BAOABLangevin\u0026rdquo; \u0026ldquo;g-BAOABLangevin\u0026rdquo; \u0026ldquo;UnderdampedLangevin\u0026rdquo; \u0026ldquo;VelocityVerlet\u0026rdquo; 参考：integrators.    schedule Table #   type: 文字列型  温度の変化させ方を指定します。以下の種類がサポートされています。 \u0026quot;linear\u0026quot;: 線形に変化させます。   begin: 浮動小数点数型  \u0026quot;linear\u0026quot;な温度変化において、時刻0での温度を指定します。単位は[K]です。   end: 浮動小数点数型  \u0026quot;linear\u0026quot;な温度変化において、最終時刻での温度を指定します。単位は[K]です。    "}),e.add({id:19,href:"/Mjolnir/ja/docs/reference/forcefields/external/",title:"External",section:"ForceFields",content:"ExternalForceField #  外場との相互作用を指定します。\nPositionRestraintInteraction #  粒子を空間中の点に固定します。空間中の点から一定距離の位置に固定することもできます。\nRectangularBoxInteraction #  系全体を直方体の箱の中に閉じ込めます。周期境界条件と同時には使えません。\nExternalDistanceInteraction #  粒子と空間中の物体、壁などとの間の距離に依存したポテンシャルを指定します。\nAFMFittingInteraction #  AFM画像への構造のフレキシブルフィッティングを行います。\n系の擬似AFM画像を生成し、参照AFM画像との相関係数に応じたポテンシャルをかけます。\nPullingForceInteraction #  指定した粒子に、一定の力をかけ続けます。\nCoMPullingForceInteraction #  指定した粒子グループの重心に、一定の力をかけ続けます。力は重みづけられてそれぞれの粒子にかかります。\n"}),e.add({id:20,href:"/Mjolnir/ja/docs/reference/integrators/G-JFLangevinIntegrator/",title:"G-JFLangevin",section:"Integrators",content:"G-JFLangevin #  ランジュバン方程式に従い、温度・体積・粒子数 (NVT) 一定のシミュレーションを行います。\n  \\[m\\frac{d^2 \\bold{r}}{dt^2} = \\bold{f}(\\bold{r}) - \\alpha\\bold{v} \u0026#43; \\beta(t)\\]  以下の論文で提案された手法です。\n Niels Grønbech-Jensen \u0026amp; Oded Farago, (2013) Mol.Phys. 111:8, 983-991  例 #  [simulator] # ... integrator.type = \u0026#34;G-JFLangevin\u0026#34; integrator.alphas = [  {index = 0, alpha = 1.0},  {index = 1, alpha = 1.0},  # ... ] 入力 #  delta_tなどの他のパラメータはSimulatorで設定します。\n type: 文字列型  Integratorの種類を指定します。\u0026quot;G-JFLangevin\u0026quot;です。   alphas: テーブルの配列型  粒子の摩擦係数 \\(\\alpha_i\\)  を指定します。   remove: テーブル型 (optional)  translation: 論理値型  trueの場合、毎ステップ、系全体の並進速度成分を取り除きます。   rotation: 論理値型  trueの場合、毎ステップ、系全体の回転速度成分を取り除きます。   rescale: 論理値型  trueになっていた場合、全体の速度ベクトルをリスケールすることで速度を減算した分の運動エネルギーを補填します。   省略した場合、全てfalseになります。    "}),e.add({id:21,href:"/Mjolnir/ja/docs/reference/simulators/SteepestDescentSimulator/",title:"SteepestDescent",section:"Simulators",content:"SteepestDescent #  最急降下法のためのシミュレータです。\nsystemを一つ、forcefieldを一つ要求します。\n例 #  [simulator] type = \u0026#34;SteepestDescent\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; delta = 1e-4 threshold = 1e-4 step_limit = 1_000_000 save_step = 100 入力 #  以下のパラメータを取ります。\n type: 文字列型  シミュレータの種類を指定します。このシミュレータを使う場合、\u0026quot;SteepestDescent\u0026quot;です。   boundary_type: 文字列型  境界条件の種類を指定します。具体的な大きさはSystemで指定します。 \u0026quot;Unlimited\u0026quot;: 境界条件を設定しません。シミュレーションボックスは無限大の大きさになります。 \u0026quot;PeriodicCuboid\u0026quot;: 直方体型の周期境界条件を指定します。   precision: 文字列型  シミュレーションに用いる浮動小数点数型の種類を指定します。 \u0026quot;float\u0026quot;: 32bit浮動小数点数を使用します。 \u0026quot;double\u0026quot;: 64bit浮動小数点数を使用します。   delta: 浮動小数点数型  一ステップで勾配の大きさのどれだけの割合だけ粒子を動かすかを指定します。   threshold: 浮動小数点数型  一ステップで最も大きく動いた粒子の動きがこれを下回った場合、収束したとして終了します。   step_limit: 整数型  ステップ数の上限を指定します。このステップ数に達すると、収束したかに関わらず終了します。   save_step: 整数型  何ステップおきに状態を出力するか指定します。 この値に関わらず、収束して終了した場合は最終状態が最終ステップとして出力されます。    "}),e.add({id:22,href:"/Mjolnir/ja/docs/reference/forcefields/constraint/",title:"Constraint",section:"ForceFields",content:"ConstraintForceField #  ConstraintForceFieldでは、特定の粒子間の距離に拘束をかけられます。\n現在、g-BAOABLangevinIntegratorのみが拘束条件を扱うことができます。\n例 #  [[forcefields.constraint]] topology = \u0026#34;bond\u0026#34; max_iteration = 500 tolerance = 1e-6 parameters = [  {indices = [0, 1], offset = 100, v0 = 3.8},  # ... ] 入力 #  ConstraintForceFieldを用いる場合、[[forcefields.constraint]]テーブルには以下の値を設定します。\n topology: 文字列型  \u0026quot;Topology\u0026quot;に設定する名前を指定します。   max_iteration: 整数型  収束するまで最大これだけの回数補正を繰り返します。 収束しなかった場合、warningが出力されますが、シミュレーションの実行は継続します。ただし、発散することが多いです。   tolerance: 浮動小数点数型  収束判定に用いる許容誤差を指定します。距離の差がこの値以下になれば補正の必要はないと判断されます。   parameters: テーブルの配列型  indices: 整数の配列型  どの粒子の間の距離に適用するかを指定します。最初の粒子は0番目です。   offset: 整数型(optional)  indicesに加算する値です。省略可能です。グループ内番号を使いたい場合に便利です。   v0: 浮動小数点数型  拘束する距離です。      Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:23,href:"/Mjolnir/ja/docs/reference/integrators/GFWNPTLangevinIntegrator/",title:"GFWNPTLangevin",section:"Integrators",content:"GFWNPTLangevin #  ランジュバン方程式に従い、温度・圧力・粒子数 (NPT) 一定のシミュレーションを行います。\n  \\[m\\frac{d^2 \\bold{r}}{dt^2} = \\bold{f}(\\bold{r}) - m\\gamma\\bold{v} \u0026#43; \\beta(t)\\]  以下の論文で提案された手法です。\n Xingyu Gao, Jun Fang, and Han Wang. J. Chem. Phys. (2016) 144, 124113  例 #  [simulator] # ... integrator.type = \u0026#34;GFWNPTLangevin\u0026#34; integrator.chi = 0.0 integrator.cell_mass = [1e3, 1e3, 1e3] integrator.cell_gamma = [0.1, 0.1, 0.1] integrator.gammas = [  {index = 0, gamma = 0.1},  {index = 1, gamma = 0.1},  # ... ] 入力 #  delta_tなどの他のパラメータはSimulatorで設定します。\n type: 文字列型  Integratorの種類を指定します。\u0026quot;BAOABLangevin\u0026quot;です。   chi: 浮動小数点数  パラメータ \\( chi \\)  の値です。   cell_mass: 浮動小数点数の配列型  箱の運動に対応する質量です。   cell_gamma: 浮動小数点数の配列型  箱の運動に対応する摩擦係数です。   gammas: テーブルの配列型  粒子の摩擦係数 \\(\\gamma_i\\)  を指定します。   remove: テーブル型 (optional)  translation: 論理値型  trueの場合、毎ステップ、系全体の並進速度成分を取り除きます。   rotation: 論理値型  trueの場合、毎ステップ、系全体の回転速度成分を取り除きます。   rescale: 論理値型  trueになっていた場合、全体の速度ベクトルをリスケールすることで速度を減算した分の運動エネルギーを補填します。   省略した場合、全てfalseになります。    "}),e.add({id:24,href:"/Mjolnir/ja/docs/reference/simulators/SwitchingForceFieldSimulator/",title:"SwitchingForceField",section:"Simulators",content:"SwitchingForceField #  あらかじめ決めた時間ステップに使用する力場を変更するシミュレータです。\nsystemを一つ、forcefieldを複数個（必要なだけ）要求します。\nExample #  [simulator] type = \u0026#34;SwitchingForceField\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; delta_t = 0.1 total_step = 3_000_000 save_step = 100 seed = 2374  integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.parameters = [ {index = 0, gamma = 1.00}, {index = 1, gamma = 1.00}, ]  schedule = [  {until = 1_000_000, forcefield = \u0026#34;close\u0026#34;},  {until = 2_000_000, forcefield = \u0026#34;open\u0026#34;},  {until = 3_000_000, forcefield = \u0026#34;close\u0026#34;}, ]  [[forcefields]] name = \u0026#34;close\u0026#34; [[forcefields.local]] # ...  [[forcefields]] name = \u0026#34;open\u0026#34; [[forcefields.local]] # ... Input Reference #   type: 文字列型  シミュレータの種類を指定します。このシミュレータを使う場合、\u0026quot;SwitchingForceField\u0026quot;です。   boundary_type: 文字列型  境界条件の種類を指定します。具体的な大きさはSystemで指定します。 \u0026quot;Unlimited\u0026quot;: 境界条件を設定しません。シミュレーションボックスは無限大の大きさになります。 \u0026quot;PeriodicCuboid\u0026quot;: 直方体型の周期境界条件を指定します。   precision: 文字列型  シミュレーションに用いる浮動小数点数型の種類を指定します。 \u0026quot;float\u0026quot;: 32bit浮動小数点数を使用します。 \u0026quot;double\u0026quot;: 64bit浮動小数点数を使用します。   parallelism: 文字列型(省略可)  並列化する際の実装を選択します。 \u0026quot;OpenMP\u0026quot;: OpenMPを使った実装を使用します。 \u0026quot;sequencial\u0026quot;: 並列化を行いません。省略した場合はこれが選択されます。   seed: 整数型  乱数生成器の初期化に用いるシードを設定します。   delta_t: 浮動小数点数型  シミュレーションの時間刻みを指定します。 時間の単位はunitsで指定した単位系に依存します。   total_step: 整数型  実行するステップ数を指定します。   save_step: 整数型  何ステップおきに状態を出力するか指定します。   integrator: テーブル型  時間積分の方法を指定します。積分方法によって必要なパラメータが異なります。 以下のアルゴリズムが使用可能です。 \u0026ldquo;BAOABLangevin\u0026rdquo; \u0026ldquo;g-BAOABLangevin\u0026rdquo; \u0026ldquo;UnderdampedLangevin\u0026rdquo; \u0026ldquo;VelocityVerlet\u0026rdquo; 参考：integrators.   schedule: テーブルの配列型  使用する力場のスケジュールを決めます。以下で詳細を説明します。    schedule #  テーブルの配列で、各テーブルが以下のパラメータを持ちます。\n until: 整数型  この時間ステップになるまで、指定された力場を使用します。 この時間ステップ以降は、次の力場を使用します。   forcefield: 文字列型  使用する力場の名前を指定します。    forcefieldには、[[forcefields]]直下のnameで指定した名前を使って下さい。\n[[forcefields]] name = \u0026#34;close\u0026#34;  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; # ここは`close`の一員になります  [[forcefields.local]] interaction = \u0026#34;BondAngle\u0026#34; potential = \u0026#34;Harmonic\u0026#34; # ここも`close`の一員になります # ...  [[forcefields]] name = \u0026#34;open\u0026#34;  [[forcefields.local]] # これ以降は`open`の一員になります # ... "}),e.add({id:25,href:"/Mjolnir/ja/docs/reference/simulators/EnergyCalculationSimulator/",title:"EnergyCalculation",section:"Simulators",content:"EnergyCalculation #  トラジェクトリファイルからエネルギーを計算するシミュレータです。\nForceFieldを指定して、トラジェクトリファイルのそれぞれのスナップショットでのエネルギーを計算します。\nこのシミュレータにIntegratorは必要ありません。\nまた、[[systems]]で指定された座標はトラジェクトリファイルの座標で上書きされます。 ですが、グループや名前の指定のため、[[systems]]自体は必要です。\n例 #  [simulator] type = \u0026#34;EnergyCalculation\u0026#34; boundary_type = \u0026#34;PeriodicCuboid\u0026#34; precision = \u0026#34;double\u0026#34; parallelism = \u0026#34;OpenMP\u0026#34; # optional file = \u0026#34;example_position.dcd\u0026#34; 入力 #  以下のパラメータを取ります。\n type: 文字列型  シミュレータの種類を指定します。このシミュレータを使う場合、\u0026quot;MolecularDynamics\u0026quot;です。   boundary_type: 文字列型  境界条件の種類を指定します。具体的な大きさは[[systems]]で指定します。 \u0026quot;Unlimited\u0026quot;: 境界条件を設定しません。シミュレーションボックスは無限大の大きさになります。 \u0026quot;PeriodicCuboid\u0026quot;: 直方体型の周期境界条件を指定します。   precision: 文字列型  シミュレーションに用いる浮動小数点数型の種類を指定します。 \u0026quot;float\u0026quot;: 32bit浮動小数点数を使用します。 \u0026quot;double\u0026quot;: 64bit浮動小数点数を使用します。   parallelism: 文字列型(省略可)  並列化する際の実装を選択します。 \u0026quot;OpenMP\u0026quot;: OpenMPを使った実装を使用します。 \u0026quot;sequencial\u0026quot;: 並列化を行いません。省略した場合はこれが選択されます。   file: 文字列型  エネルギーを計算するトラジェクトリファイルを指定します。 [files]で指定した入力パスに従います。    "}),e.add({id:26,href:"/Mjolnir/ja/docs/reference/forcefields/MultipleBasinForceField/",title:"MultipleBasin",section:"ForceFields",content:"MultipleBasinForceField #  MultipleBasin モデルによって、複数の異なる力場をスムースにつなげることができます。\n粗視化モデルでタンパク質の構造変化を実現するための、力場の強制変更よりも自然な方法として、以下の文献で提案されました。\n Kei-ichi Okazaki, Nobuyasu Koga, Shoji Takada, Jose N. Onuchic, and Peter G. Wolynes PNAS (2006)  Mjolnirはこれを一般化した形で実装しており、任意の力場を利用できます。\nこのモデルでは、以下の形で定義された行列の最小固有値として定義される   \\( V_{MB} \\)  がかかります。\n \\[\\begin{pmatrix} V_1 \u0026#43; \\Delta V_1 \u0026amp; \\Delta \\\\ \\Delta \u0026amp; V_2 \u0026#43; \\Delta V_2 \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} = V_{MB} \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix}\\]  固有ベクトルの成分は、それぞれの状態の重みと解釈できます。反応座標として、デフォルトで以下の値が出力されます。\n \\[\\chi = \\log\\left(\\frac{c_2}{c_1}\\right)\\]   \\( 0 \u0026lt; \\Delta \\)  の場合、この値が非数になることに注意してください。これを避けるため、Mjolnirでは \\(\\Delta\\)  が常に負の値として読み込まれます。  \\( V_{MB} \\)  は  \\( \\Delta^2 \\)  にしか依存しないため、 \\( \\Delta \\)  の符号は結果に影響しません。\n力場が2つの場合に限って、 \\( \\chi \\)  の値にHarmonic potentialで拘束をかけることができます。\n \\[V_{Bias} = k (\\chi - \\chi_0)^2\\]  例えば、反応座標である \\( \\chi \\)  に沿ってアンブレラサンプリングをすることができるでしょう。 これによって、 \\( \\Delta \\)  や \\( \\Delta V \\)  の値を決定するのが容易になります。\n 3つの異なる力場をつなげる際には、以下の形になります。\n \\[\\begin{pmatrix} V_1 \u0026#43; \\Delta V_1 \u0026amp; \\Delta_{12} \u0026amp; \\Delta_{13} \\\\ \\Delta_{21} \u0026amp; V_2 \u0026#43; \\Delta V_2 \u0026amp; \\Delta_{23} \\\\ \\Delta_{31} \u0026amp; \\Delta_{32} \u0026amp; V_3 \u0026#43; \\Delta V_3 \\\\ \\end{pmatrix} \\begin{pmatrix} c_1 \\\\ c_2 \\\\ c_3 \\end{pmatrix} = V_{MB} \\begin{pmatrix} c_1 \\\\ c_2 \\\\ c_3 \\end{pmatrix}\\]  ここで、 \\(\\Delta_{ij} = \\Delta_{ji}\\)  です。\n現在、Mjolnirは力場の数が2つまたは3つの場合のみをサポートしています。 さらに、異なるトポロジーを持つ力場同士のMultipleBasinはサポートしていません。\n例 #  まず、繋ぎ合わせるための複数種類の力場を設定し、名前をつけます。 この時、\u0026quot;common\u0026quot;という名前の力場はMultipleBasinに含まれず常に適用されるようになることに注意してください。\nその後、[simulator]でMultipleBasinを利用することを宣言し、力場の名前と、カップリングパラメータを指定します。\n独立に構造変化を起こす複数のタンパク質をサポートする場合などのために、複数のMultipleBasinを並行して定義できるようになっています。 simulator.forcefields.unitsで必要な数のMultipleBasinを定義してください。\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; delta_t = 0.1 total_step = 1000000 save_step = 1_000 seed = 2859805901 integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  # ... ] forcefields.type = \u0026#34;MultipleBasin\u0026#34; forcefields.units = [ {basins = [\u0026#34;open\u0026#34;, \u0026#34;close\u0026#34;], dVs = [0.0, -12.0], delta = 150.0}, # ... ] # # Or, the following has the same meaning. #  # [simulator.forcefields] # type = \u0026#34;MultipleBasin\u0026#34; # [[simulator.forcefields.units]] # basins = [\u0026#34;open\u0026#34;, \u0026#34;close\u0026#34;], # dVs = [0.0, -12.0], # delta = 150.0,  [[forcefields]] name = \u0026#34;open\u0026#34; [[forcefields.local]] # ...  [[forcefields]] name = \u0026#34;close\u0026#34; [[forcefields.local]] # ...  [[forcefields]] name = \u0026#34;common\u0026#34; [[forcefields.local]] # ...  \\( \\chi \\)  に拘束力をかけるには、k_chiとchi_0を設定してください。\nforcefields.type = \u0026#34;MultipleBasin\u0026#34; forcefields.units = [ {basins = [\u0026#34;open\u0026#34;, \u0026#34;close\u0026#34;], dVs = [0.0, -12.0], delta = 150.0, k_chi = 100.0, chi_0 = 0.0}, ] 3つの力場を繋げる場合には、以下のようにしてください。\n[simulator.forcefields] type = \u0026#34;MultipleBasin\u0026#34; [[simulator.forcefields.units]] basins = [\u0026#34;open\u0026#34;, \u0026#34;mid\u0026#34;, \u0026#34;close\u0026#34;] dVs = [ 0.0, 15.0, -10.0] delta.open-mid = 60.0 # basinの名前をハイフンで繋げてください。 delta.mid-close = 50.0 # 混乱を避けるため、basinの名前にはハイフンを入れないでください。 delta.close-open = 100.0 AICG2+力場で用いる時の注意 #  AICG2+力場を用いる際は、結合長とコンタクトの扱いに注意が必要です。\n結合長ポテンシャルへの補正 #  遷移状態のエネルギーを上げすぎないように、自然長が大きく違う場合、以下の形でポテンシャルの係数を補正します。\n \\[K\u0026#39;_{bond} = K_{bond} \\times \\mathrm{min}\\left(1, \\frac{E_{max}}{K_b(b_i^{(1)} - b_i^{(2)})^2}\\right)\\]  通常、 \\( E_{max} \\)  の値は100 kcal/molが用いられます。\nコンタクトポテンシャルへの補正 #  また、GoContactは引力項と斥力項に分割され、最も短い参照距離を持つコンタクトの斥力項を全ての力場で共有します。\n もしある粒子のペアが全ての参照構造でコンタクトを持っていた場合、斥力項のうち最も距離の短いものが全てに適用されます。引力項はそれぞれのものが用いられます。 もしある粒子のペアが一部の参照構造でのみコンタクトを持っていた場合、斥力項のうち最も距離の短いものがコンタクトを持っていなかった参照構造由来のポテンシャルにも適用されます。 もしある粒子のペアがどの参照構造でもコンタクトを持っていない場合、補正の必要はありません。  "}),e.add({id:27,href:"/Mjolnir/ja/docs/reference/integrators/UnderdampedLangevinIntegrator/",title:"UnderdampedLangevin",section:"Integrators",content:"UnderdampedLangevin #  ランジュバン方程式に従い、温度・体積・粒子数一定のシミュレーションを行います。\n  \\[m\\frac{d^2 \\bold{r}}{dt^2} = \\bold{f}(\\bold{r}) - m\\gamma\\bold{v} \u0026#43; \\beta(t)\\]  以下の論文で提案された手法です。\n J. D. Honeycutt and D. Thirumalai, (1992) Biopolymers Z. Guo and D. Thirumalai, (1995) Biopolymers.  例 #  [simulator] integrator.type = \u0026#34;UnderdampedLangevin\u0026#34; integrator.gammas = [  {index = 0, gamma = 1.0},  {index = 1, gamma = 1.0},  # ... ] 入力 #  delta_tなどの他のパラメータはSimulatorで設定します。\n type: 文字列型  Integratorの種類を指定します。\u0026quot;BAOABLangevin\u0026quot;です。   gammas: テーブルの配列型  粒子の摩擦係数 \\(\\gamma_i\\)  を指定します。   remove: テーブル型 (optional)  translation: 論理値型  trueの場合、毎ステップ、系全体の並進速度成分を取り除きます。   rotation: 論理値型  trueの場合、毎ステップ、系全体の回転速度成分を取り除きます。   rescale: 論理値型  trueになっていた場合、全体の速度ベクトルをリスケールすることで速度を減算した分の運動エネルギーを補填します。   省略した場合、全てfalseになります。    "}),e.add({id:28,href:"/Mjolnir/ja/docs/reference/forcefields/HybridForceField/",title:"HybridForceField",section:"ForceFields",content:"HybridForceField #  HybridForceField は二つの異なる力場の線形結合です。\n  \\[V = \\lambda V_1 \u0026#43; (1 - \\lambda) V_2\\]   \\(\\lambda = 1\\)  のとき、 \\(V = V_1\\)  になることに気を付けてください。\nトポロジーは異なっていても問題ありません。異なっている場合、dcdなどのchain数には一つ目のforcefieldが入ります。\n例 #  まず、二つのforcefieldsを定義します。\nその後、[simulator]テーブルでforcefields.type = \u0026quot;Hybrid\u0026quot;と、forcefields.lambdaの値を定義してください。 一番目の[[forcefields]]テーブルが上の式での \\( V_1 \\)  に、二番目が \\( V_2 \\)  になります。\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; delta_t = 0.1 total_step = 1000000 save_step = 1_000 seed = 2859805901 integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  # ... ] forcefields.type = \u0026#34;Hybrid\u0026#34; forcefields.lambda = 0.5 # ...  [[forcefields]] # V1 [[forcefields.local]] # ...  [[forcefields]] # V2 [[forcefields.local]] # ... λの値を動的に変化させる #   \\(\\lambda\\)  を仮想的な粒子の座標と解釈し、それにかかる力を考え、時間積分することによってサンプリングを行うことが可能です。 forcefields.lambdaには文字列で\u0026quot;dynamic\u0026quot;と入力し、[[systems]]でdynamic_variablesにlambdaを定義してください。 このlambdaの値、速度、力は.eneファイルに保存されます。\nまた、その際に \\(k(\\lambda - \\lambda_0)^2\\)  型のポテンシャルを追加でかけることが可能です。\n[simulator] type = \u0026#34;MolecularDynamics\u0026#34; boundary_type = \u0026#34;Unlimited\u0026#34; precision = \u0026#34;double\u0026#34; delta_t = 0.1 total_step = 1000000 save_step = 1_000 seed = 2859805901 integrator.type = \u0026#34;BAOABLangevin\u0026#34; integrator.gammas = [  # ... ] forcefields.type = \u0026#34;Hybrid\u0026#34; forcefields.lambda = \u0026#34;dynamic\u0026#34; # make lambda dynamic forcefields.v0_lambda = 1.0 # k(v - v0)^2 forcefields.k_lambda = 100.0 # k(v - v0)^2  # ...  [[systems]] attributes.temperature = 300.0 dynamic_variables.lambda = {x = 1.0, m = 1000.0, gamma = 1e-5, boundary = \u0026#34;Repulsive\u0026#34;, lower = 0.0, upper = 1.0}  [[forcefields]] # V1 [[forcefields.local]] # ...  [[forcefields]] # V2 [[forcefields.local]] # ... "}),e.add({id:29,href:"/Mjolnir/ja/docs/reference/forcefields/Topology/",title:"Topology",section:"ForceFields",content:"Topology #  LocalForceFieldはGlobalForceFieldに影響することがあります。 例えば、結合長ポテンシャルが適用されている粒子同士には排除体積効果が働かない、というケースがあります。\nこの情報をLocalForceFiledとGlobalForceFieldと共有するため、Topologyクラスがあり、Systemに格納されています。 Topologyクラスには粒子をノード、LocalForceFieldをエッジとしたグラフ構造が格納されており、その上を検索することができます。\nLocalForceFieldでは、それぞれに名前を付けてTopologyとして登録することができます。 GlobalForceFieldでは、名前のついたエッジを辿って見つかる粒子を無視することができます。\n[[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], ... },  # ... ]  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;ExcludedVolume\u0026#34; ignore.particles_within.bond = 3 # ignore particles within 3 bonds. ignore.particles_within.contact = 1 # ignore particles within 1 contact. # ... parameters = [  # ... ] "}),e.add({id:30,href:"/Mjolnir/ja/docs/reference/integrators/VelocityVerletIntegrator/",title:"VelocityVerlet",section:"Integrators",content:"VelocityVerlet #  ニュートンの運動方程式に従い、エネルギー・体積・粒子数一定のシミュレーションを行います。\n例 #  [simulator] integrator.type = \u0026#34;VelocityVerlet\u0026#34; integrator.remove.translation = true integrator.remove.rotation = true integrator.remove.rescale = true 入力 #  delta_tなどの他のパラメータは[simulator]で設定します。\n type: 文字列型  Integratorの種類を指定します。\u0026quot;VelocityVerlet\u0026quot;です。   remove: テーブル型 (optional)  translation: 論理値型  trueの場合、毎ステップ、系全体の並進速度成分を取り除きます。   rotation: 論理値型  trueの場合、毎ステップ、系全体の回転速度成分を取り除きます。   rescale: 論理値型  trueになっていた場合、全体の速度ベクトルをリスケールすることで速度を減算した分の運動エネルギーを補填します。   省略した場合、全てfalseになります。    "}),e.add({id:31,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondlength/",title:"BondLength",section:"Local",content:"BondLengthInteraction #  BondLength相互作用は、その名の通り結合長にかかる相互作用です。\n以下のポテンシャルが利用可能です。\n Harmonic Gaussian GoContact AttractiveGoContact RepulsiveGoContact WormLikeChain WormLikeChainOffset 3SPN2Bond  例 #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  # required parameters depend on a potential...  {indices = [0, 1], offset = 100, ... }, ] 入力 #   interaction: 文字列型  相互作用の名前です。\u0026quot;BondLength\u0026quot;を指定します。   potential: 文字列型  利用可能なポテンシャルは以下のとおりです。 Harmonic Gaussian GoContact AttractiveGoContact RepulsiveGoContact WormLikeChain 3SPN2Bond   topology: 文字列型  Topologyにおける結合の名称です。   parameters: テーブルの配列型  indices: 整数の配列型(長さ: 2)  どの粒子の間の距離に適用するかを指定します。最初の粒子は0番目です。   offset: 整数型(省略可能)  indicesに加算する値です。省略可能です。グループ内番号を使いたい場合に便利です。   他のパラメータは、ポテンシャルによって異なります。    "}),e.add({id:32,href:"/Mjolnir/ja/docs/reference/forcefields/global/pair/",title:"Pair",section:"Global",content:"GlobalPair #  GlobalPairInteractionはパラメータを持つ全ての粒子の間に働く相互作用です。\n以下のポテンシャルが利用可能です。\n LennardJones UniformLennardJones DebyeHuckel ExcludedVolume InversePower HardCoreExcludedVolume WCA iSoLFAttractive 3SPN2ExcludedVolume  例 #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;ExcludedVolume\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 ignore.groups.intra = [\u0026#34;chain-A\u0026#34;] ignore.groups.inter = [[\u0026#34;chain-B\u0026#34;, \u0026#34;chain-C\u0026#34;]] spatial_partition.type = \u0026#34;CellList\u0026#34; spatial_partition.margin = 0.2 parameters = [  {index = 0, offset = 100, ...}, # required parameter depends on the potential.  # ... ] 入力 #   interaction: 文字列型  相互作用の名前です。ここでは、\u0026quot;Pair\u0026quot;です。   potential: 文字列型  以下のポテンシャルが利用可能です。 \u0026quot;LennardJones\u0026quot; \u0026quot;UniformLennardJones\u0026quot; \u0026quot;DebyeHuckel\u0026quot; \u0026quot;ExcludedVolume\u0026quot; \u0026quot;InversePower\u0026quot; \u0026quot;HardCoreExcludedVolume\u0026quot;   ignore: テーブル型  この相互作用で無視する粒子ペアの条件を決めます。 詳細はGlobalForceFieldのignoreセクションを参照してください。   spatial_partition: Table  近接リストを構築するアルゴリズムを指定します。 詳細はGlobalForceFieldのspatial_partitionセクションを参照してください。   parameters: Array of Tables  index: 整数型  粒子の番号です。最初の粒子は0番目です。   offset: 整数型 (省略可能)  各粒子の粒子番号に加算する値です。省略可能です。グループ内番号を使いたい場合に便利です。      "}),e.add({id:33,href:"/Mjolnir/ja/docs/reference/forcefields/external/PositionRestraintInteraction/",title:"PositionRestraint",section:"External",content:"PositionRestraint #  粒子を空間中の点に、あるいは空間中のある点から一定距離に保つ相互作用です。\n例 #  [[forcefields.external]] interaction = \u0026#34;PositionRestraint\u0026#34; potential = \u0026#34;Harmonic\u0026#34; parameters = [  {index = 0, position = [0.0, 0.0, 0.0], k = 0.1, v0 = 10.0},  # ... ] 入力 #   interaction: 文字列型  相互作用の名前です。\u0026quot;PositionRestraint\u0026quot;を指定します。   potential: 文字列型  点との距離に適用するポテンシャルを指定します。 \u0026quot;Harmonic\u0026quot;: 調和振動子ポテンシャルを使用します。   parameters: テーブルの配列型  index: 整数型  適用する粒子の番号を指定します。   offset: 整数型（省略可能）  indicesに加算する値です。省略可能です。グループ内番号を使いたい場合に便利です。   position: 浮動小数点数の配列型  粒子を固定する位置を指定します。   k: 浮動小数点数型  ポテンシャルの強さを決めます。   v0: 浮動小数点数型  点からの距離を決めます。 点の位置に固定したい場合、0にしてください。      "}),e.add({id:34,href:"/Mjolnir/ja/docs/reference/forcefields/global/3SPN2BaseBaseInteraction/",title:"3SPN2Base",section:"Global",content:"3SPN2BaseBaseInteraction #  3SPN2BaseBaseInteractionは3SPN2系粗視化DNA力場の相互作用です。\n以下のポテンシャルが利用可能です。\n \u0026quot;3SPN2\u0026quot;: Hinckley et al., (2013) JCP \u0026quot;3SPN2C\u0026quot;: Freeman et al., (2014) JCP  例 #  [[forcefields.global]] interaction = \u0026#34;3SPN2BaseBase\u0026#34; potential = \u0026#34;3SPN2\u0026#34; ignore.particles_within.nucleotide = 3 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2} parameters = [ # `nucleotide` index starts from 5\u0026#39; and ends at 3\u0026#39;. {strand = 0, nucleotide = 0, S = 0, B = 1, offset = 100, Base = \u0026#34;A\u0026#34;}, {strand = 0, nucleotide = 1, P = 2, S = 3, B = 4, offset = 100, Base = \u0026#34;T\u0026#34;}, {strand = 0, nucleotide = 2, P = 5, S = 6, B = 7, offset = 100, Base = \u0026#34;C\u0026#34;}, # ... ] 入力 #   interaction: 文字列型  相互作用の種類を設定します。3SPN2BaseBaseです。   potential: 文字列型  以下のポテンシャルが利用可能です。 3SPN2 : 3SPN.2ポテンシャルのパラメータを使います。 3SPN2C: 3SPN.2Cポテンシャルのパラメータを使います。   topology: 文字列型  \u0026quot;Topology\u0026quot;に設定する名前を指定します。 3SPN2力場では3つのヌクレオチドが間にないと塩基対を形成しないので、BaseStackingの トポロジーとして設定した結合(ここでは\u0026quot;nucleotide\u0026quot;)を3つ分無視して下さい。 詳細はGlobalForceFieldのignoreセクションを参照してください。   spatial_partition: Table  近接リストを構築するアルゴリズムを指定します。 詳細はGlobalForceFieldのspatial_partitionセクションを参照してください。   parameters:テーブルの配列型  strand: 整数型  ストランドの番号です。0-basedなインデックスです。   nucleotide: Integer  ヌクレオチドの番号です。0-basedなインデックスです。   P, S, B: 整数型  リン酸(P), 糖(S), 塩基(B)の番号です。0-basedなインデックスです。   Base: String  \u0026quot;A\u0026quot;, \u0026quot;T\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;G\u0026quot;のいずれかです。   offset: 整数型(optional)  各粒子の粒子番号に加算する値です。省略可能です。グループ内番号を使いたい場合に便利です。   端のヌクレオチドには、多くの場合リン酸がありません。    "}),e.add({id:35,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondangle/",title:"BondAngle",section:"Local",content:"BondAngleInteraction #  BondAngle相互作用は、結合角にかかる相互作用です。\n以下のポテンシャルが利用可能です。\n Harmonic Gaussian FlexibleLocalAngle  例 #  [[forcefields.local]] interaction = \u0026#34;BondAngle\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  # required parameters depend on a potential...  {indices = [0, 1, 2], offset = 100, ... }, ] 入力 #   interaction: 文字列型  相互作用の名前です。\u0026quot;BondAngle\u0026quot;を指定します。   potential: 文字列型  以下のポテンシャルが利用可能です。 Harmonic Gaussian FlexibleLocalAngle   topology: 文字列型  \u0026quot;Topology\u0026quot;での名前を指定します。   parameters: テーブルの配列型  indices: 整数の配列型（長さ: 3）  どの粒子の間の距離に適用するかを指定します。最初の粒子は0番目です。   offset: 整数型(optional)  indicesに加算する値です。省略可能です。グループ内番号を使いたい場合に便利です。   他のパラメータは、ポテンシャルによって異なります。    "}),e.add({id:36,href:"/Mjolnir/ja/docs/reference/forcefields/external/rectangularbox/",title:"RectangularBox",section:"External",content:"RectangularBox #  RectangularBoxは粒子を箱の中に拘束する相互作用です。\n初期位置で粒子が箱の外に出ていた場合、エラーで終了します。  周期境界条件が課せられていた場合、機能しません。境界条件は設定しないようにしてください。  例 #  [[forcefields.external]] interaction = \u0026#34;RectangularBox\u0026#34; potential = \u0026#34;ExcludedVolumeWall\u0026#34;  box.lower = [ 0.0, 0.0, 0.0] box.upper = [100.0, 100.0, 100.0] box.margin = 0.4  # potential related epsilon = 0.1 parameters = [  {index = 0, radius = 1.0}, # required parameters depend on potential. ] 入力 #   interaction: 文字列型  相互作用の名前です。ここでは、\u0026quot;RectangularBox\u0026quot;です。   potential: 文字列型  \u0026quot;LennardJonesWall\u0026quot; \u0026quot;ExcludedVolumeWall\u0026quot;   box: テーブル型  box.lower: 浮動小数点数の配列型（長さ: 3）  箱の座標が小さい方の頂点です。   box.upper: 浮動小数点数の配列型（長さ: 3）  箱の座標が大きい方の頂点です。   box.margin: 浮動小数点数型  内部で用いる近接リストのマージンです。カットオフ長に対する相対値です。      "}),e.add({id:37,href:"/Mjolnir/ja/docs/reference/forcefields/local/dihedral/",title:"DihedralAngle",section:"Local",content:"DihedralAngleInteraction #  DihedralAngle相互作用は、二面角にかかる相互作用です。\n以下のポテンシャルが利用可能です。\n Cosine Gaussian ClementiDihedral FlexibleLocalDihedral  例 #  [[forcefields.local]] interaction = \u0026#34;DihedralAngle\u0026#34; potential = \u0026#34;Cosine\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  # required parameters depend on a potential...  {indices = [0, 1, 2, 3], ... }, ]  interaction: String  Name of the interaction. Here, it is \u0026quot;BondLength\u0026quot;.   potential: String  The following potentials are available. Cosine Gaussian ClementiDihedral FlexibleLocalDihedral   topology: String  Name of the connection in Topology.   parameters: Array of Tables  indices: Array of Integers (length = 3)  Indices of particles that interact with each other. The index is 0-based.   offset: Integer(Optional. By default, 0.)  Offset of index.   The other parameter depends on the specified potential.    入力 #   interaction: 文字列型  相互作用の名前です。\u0026quot;DihedralAngle\u0026quot;を指定します。   potential: 文字列型  Cosine Gaussian ClementiDihedral FlexibleLocalDihedral   topology: 文字列型  Topologyに設定する名前を指定します。   parameters: テーブルの配列型  indices: 整数の配列型  どの粒子の間の距離に適用するかを指定します。最初の粒子は0番目です。   offset: 整数型(省略可能)  indicesに加算する値です。省略可能です。グループ内番号を使いたい場合に便利です。   他のパラメータは、ポテンシャルによって異なります。    Combination #  いくつかの力場では、同じ二面角に複数のポテンシャルが適用されていることがあります。 そのような場合に計算を高速化するため、以下の組み合わせがサポートされています。\n \u0026quot;Gaussian+FlexibleLocalDihedral\u0026quot; \u0026quot;Gaussian+Cosine\u0026quot;  それぞれのポテンシャルのパラメータは、PotentialName = {...}のようなインラインテーブルとして設定します。\n[[forcefields.local]] interaction = \u0026#34;DihedralAngle\u0026#34; potential = \u0026#34;Gaussian+FlexibleLocalDihedral\u0026#34; topology = \u0026#34;none\u0026#34; env.ALA-ALA = [2.2056, 0.2183, -0.0795, 0.0451, -0.3169, 0.0165, -0.1375] parameters = [ {indices = [0,1,2,3], Gaussian = {v0=-2.2, k=-0.43,sigma=0.15}, FlexibleLocalDihedral = {k=1.0, coef=\u0026#34;ALA-ALA\u0026#34;}}, # ... ] "}),e.add({id:38,href:"/Mjolnir/ja/docs/reference/forcefields/external/distance/",title:"Distance",section:"External",content:"ExternalDistance #  It depends on the distance between particles and a structure such as a planner surface.\nExample #  [[forcefields.external]] interaction = \u0026#34;Distance\u0026#34; potential = \u0026#34;LennardJonesWall\u0026#34; shape.name = \u0026#34;AxisAlignedPlane\u0026#34; shape.axis = \u0026#34;X\u0026#34; shape.position = 0.0 shape.margin = 0.5 parameters = [ # ... ] Input Reference #   interaction: String  Name of the interaction. Here, it is \u0026quot;Distance\u0026quot;.   potential: String  The following potentials are available. \u0026quot;LennardJonesWall\u0026quot; \u0026quot;ExcludedVolumeWall\u0026quot; \u0026quot;ImplicitMembrane\u0026quot;   shape: Table  The shape and the position of a structure that interacts with particles.    shape #   name: String  The following shape is available. \u0026quot;AxisAlignedPlane\u0026quot; requires the following fields.  axis: String  The axis that is parpendicular to the plane. like: \u0026quot;X\u0026quot;, \u0026quot;Y\u0026quot;, \u0026quot;Z\u0026quot;.   position: Floating  The position of the plane along the axis specified.       margin: Floating  The margin of the neighborling list relative to the cutoff length.    "}),e.add({id:39,href:"/Mjolnir/ja/docs/reference/forcefields/global/ProteinDNANonSpecificInteraction/",title:"PDNS",section:"Global",content:"ProteinDNANonSpecificInteraction #  ProteinDNANonSpecificInteractionは粗視化モデルにおいてDNAとタンパク質の間の水素結合をモデル化したものです。\n以下の論文で導入されました。\n T.Niina‡, G.B.Brandani‡, C.Tan and S.Takada, (2017) PLoS Comput Biol. (‡: co-1st)  例 #  [[forcefields.global]] interaction = \u0026#34;PDNS\u0026#34; potential = \u0026#34;PDNS\u0026#34; spatial_partition.type = \u0026#34;VerletList\u0026#34; spatial_partition.margin = 0.5 sigma = 1.0 delta = 0.17453 parameters = [ {index = 2, kind = \u0026#34;DNA\u0026#34;, S3 = 1}, {index = 5, kind = \u0026#34;DNA\u0026#34;, S3 = 4}, # ... {index = 1000, offset = 100, kind = \u0026#34;Protein\u0026#34;, PN = 999, PC = 1001, k = -1.2, r0 = 5.0, theta0 = 1.57, phi0 = 1.73}, {index = 1023, offset = 100, kind = \u0026#34;Protein\u0026#34;, PN = 1022, PC = 1024, k = -1.2, r0 = 6.0, theta0 = 1.57, phi0 = 1.73}, # ... ] 入力 #   interaction: 文字列型  相互作用の名前です。\u0026quot;PDNS\u0026quot;です。   potential: 文字列型  ポテンシャルの名前です。\u0026quot;PDNS\u0026quot;です。   sigma: 浮動小数点数型  動径方向での安定化領域の幅です。   delta: 浮動小数点数型  角度方向での安定化領域の幅です。単位はラジアンです。   parameters: テーブルの配列型  index: 整数型  粒子の番号です。 DNAの場合、リン酸残基の番号です。   offset: 整数型（省略可能）  粒子のオフセットです。   kind: 文字列型  DNA粒子とProtein粒子があります。   S3: 整数型  DNA粒子で要求されます。3\u0026rsquo;末端方向にある隣のヌクレオチドの糖粒子の番号です。   PN, PC: 整数型  Protein粒子で要求されます。それぞれN-, C-末端方向の隣の粒子の番号です。   k: 浮動小数点数型  ポテンシャルの強さです。   r0, theta0, phi0: 浮動小数点数型  再安定構造です。      "}),e.add({id:40,href:"/Mjolnir/ja/docs/reference/forcefields/external/AFMFittingInteraction/",title:"AFMFitting",section:"External",content:"AFMFittingInteraction #  AFM画像への構造のフレキシブルフィッティングを行います。\n以下の論文で提案されました。\n T. Niina et al., JCTC (2020)    \\[\\begin{aligned} U(\\mathbf{r}) \u0026amp;= k(1 - \\mathrm{c.c.}(\\mathbf{r})) \\\\ \\mathrm{c.c.} \u0026amp;= \\frac{\\sum_{p\\in\\mathrm{pixels}} H_p^{\\mathrm{(exp)}} H_p^{\\mathrm{(sim)}}(\\mathbf{r})} {\\sqrt{\\sum_{p\\in\\mathrm{pixels}} \\left(H_p^{\\mathrm{(exp)}}\\right)^2} \\sqrt{\\sum_{p\\in\\mathrm{pixels}} \\left(H_p^{\\mathrm{(sim)}}(\\mathbf{r})\\right)^2}} \\\\ H_p^{\\mathrm{(sim)}}(\\mathbf{r}) \u0026amp;= \\gamma\\log\\left(1 \u0026#43; \\sum_i^N \\exp\\left(\\frac{-(x_i - x_p)^2 - (y_i - y_p)^2 }{2\\sigma^2}\\right)\\exp\\left(\\frac{z_i \u0026#43; r_i}{\\gamma}\\right)\\right) \\end{aligned}\\]  例 #  [[forcefields.external]] interaction = \u0026#34;AFMFlexibleFitting\u0026#34; k = 100.0 gamma = 1.0 pixel_x = 10.0 pixel_y = 10.0 length_x = 5 length_y = 5 sigma_x = 2.0 sigma_y = 2.0 z0 = 0.0 cutoff = 5.0 margin = 0.5 image = [  0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0,  0.0, 0.0, 0.5, 1.0, 0.5,  0.0, 0.0, 1.0, 2.0, 1.0,  0.0, 0.0, 0.5, 1.0, 0.5, ] parameters = [ {index = 0, radius = 1.0}, {index = 1, radius = 2.0}, {index = 4, radius = 3.0}, {index = 5, radius = 4.0}, ] 入力 #   interaction: 文字列型  相互作用の名前です。ここでは\u0026quot;AFMFlexibleFitting\u0026quot;です。   k: 浮動小数点数型  ポテンシャルの強さを決めます。   gamma: 浮動小数点数型  関数 \\(H\\)  のパラメータで、ソフトマックスの正確さを決めます。   pixel_x, pixel_y: 浮動小数点数型  それぞれの方向でのピクセルの大きさです。   length_x, length_y: 整数型  それぞれの方向でのピクセルの数です。   sigma_x, sigma_y: 浮動小数点数型  関数 \\( H \\)  のパラメータで、ピクセルの影響が届く範囲を決めます。   z0: 浮動小数点数型  数値誤差を抑えるための内部オフセットです。通常0で構いません。   cutoff: 浮動小数点数型  ピクセルの影響をカットオフする長さです。 \\( \\sigma \\)  との相対です。   margin: 浮動小数点数型  内部の近接リストで用いるマージンです。カットオフに対する相対です。   image: 浮動小数点数の配列型  参照AFM画像です。各ピクセルの高さを設定します。 1つめの要素がピクセル (0, 0)を、2つめが (1, 0)、\u0026hellip; (Lx, 0)、(0, 1) pixel, \u0026hellip; と続きます。 (0, 0)ピクセルは(0.0, 0.0)から(pixel_x, pixel_y)までの範囲を占める四角形です。 (n, m)ピクセルは(n*pixel_x, m*pixel_y)から((n+1)*pixel_x, (m+1)*pixel_y)までの範囲を占める四角形です。   parameters: テーブルの配列型  index: 整数型  粒子の番号です。最初の粒子は0番目です。   radius: 浮動小数点数型  粒子のAFM観測下での半径です。      "}),e.add({id:41,href:"/Mjolnir/ja/docs/reference/forcefields/local/contact/",title:"Contact",section:"Local",content:"ContactInteraction #  Contact相互作用は、粒子間距離にかかる相互作用です。\nBondLength相互作用と基本的に同じですが、シミュレーション中に力がかからない距離まで粒子が移動する可能性を考慮し、力がかからなくなったら力の計算をスキップするようになっています。\n以下のポテンシャルが利用可能です。\n Gaussian GoContact AttractiveGoContact RepulsiveGoContact  例 #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;GoContact\u0026#34; topology = \u0026#34;bond\u0026#34; margin = 0.5 # relative length to longest cutoff parameters = [  # required parameters depend on a potential...  {indices = [0, 1], ... }, ] 入力 #   interaction: 文字列型  相互作用の名前です。\u0026quot;Contact\u0026quot;を指定します。   potential: 文字列型  Gaussian GoContact AttractiveGoContact RepulsiveGoContact   topology: 文字列型  Topologyに設定する名前を指定します。   margin: 浮動小数点型  カットオフ距離に対する倍率としてマージンの長さを指定します。 定義されているポテンシャルの中で最も長いカットオフ距離に対する長さで統一されます。   parameters: テーブルの配列型  indices: 整数の配列型（長さ: 2）  どの粒子の間の距離に適用するかを指定します。最初の粒子は0番目です。   offset: 整数型(optional)  indicesに加算する値です。省略可能です。グループ内番号を使いたい場合に便利です。   他のパラメータは、ポテンシャルによって異なります。    "}),e.add({id:42,href:"/Mjolnir/ja/docs/reference/forcefields/local/3SPN2BaseStackingInteraction/",title:"3SPN2 BaseStacking",section:"Local",content:"3SPN2BaseStackingInteraction #  3SPN2BaseStacking相互作用は、3SPN2系粗視化DNA力場で用いられるbase-stackingの力場です。\n利用可能なポテンシャルは以下のものがあります。\n \u0026quot;3SPN2\u0026quot; (Hinckley et al., (2013) JCP) \u0026quot;3SPN2C\u0026quot; (Freeman et al., (2014) JCP)  例 #  [[forcefields.local]] interaction = \u0026#34;3SPN2BaseStacking\u0026#34; potential = \u0026#34;3SPN2\u0026#34; topology = \u0026#34;nucleotide\u0026#34; parameters = [ # `nucleotide` index starts from 5\u0026#39; and ends at 3\u0026#39;. {strand = 0, nucleotide = 0, S = 0, B = 1, offset = 100, Base = \u0026#34;A\u0026#34;}, {strand = 0, nucleotide = 1, P = 2, S = 3, B = 4, offset = 100, Base = \u0026#34;T\u0026#34;}, {strand = 0, nucleotide = 2, P = 5, S = 6, B = 7, offset = 100, Base = \u0026#34;C\u0026#34;}, {strand = 0, nucleotide = 3, P = 8, S = 9, B = 10, offset = 100, Base = \u0026#34;G\u0026#34;}, {strand = 1, nucleotide = 4, S = 11, B = 12, offset = 100, Base = \u0026#34;C\u0026#34;}, {strand = 1, nucleotide = 5, P = 13, S = 14, B = 15, offset = 100, Base = \u0026#34;G\u0026#34;}, {strand = 1, nucleotide = 6, P = 16, S = 17, B = 18, offset = 100, Base = \u0026#34;A\u0026#34;}, {strand = 1, nucleotide = 7, P = 19, S = 20, B = 21, offset = 100, Base = \u0026#34;T\u0026#34;}, ] 入力 #   interaction: 文字列型  相互作用の種類を設定します。 \u0026quot;3SPN2BaseStacking\u0026quot;を指定します。   potential: 文字列型  ポテンシャルの種類を設定します。 3SPN2 : 3SPN.2ポテンシャルのパラメータを使います。 3SPN2C: 3SPN.2Cポテンシャルのパラメータを使います。   topology: 文字列型  \u0026quot;Topology\u0026quot;に設定する名前を指定します。 この力場は、隣り合うヌクレオチド間の全ての粒子対にエッジを張ります。   parameters:テーブルの配列型  offset: 整数型 (省略可能)  各粒子の粒子番号に加算する値です。省略可能です。グループ内番号を使いたい場合に便利です。   strand: 整数型  ストランドの番号です。0-basedなインデックスです。   nucleotide: Integer  ヌクレオチドの番号です。0-basedなインデックスです。   P, S, B: 整数型  リン酸(P), 糖(S), 塩基(B)の番号です。0-basedなインデックスです。   Base: String  \u0026quot;A\u0026quot;, \u0026quot;T\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;G\u0026quot;のいずれかです。   offset: 整数型(optional)  各粒子の粒子番号に加算する値です。省略可能です。グループ内番号を使いたい場合に便利です。   端のヌクレオチドには、多くの場合リン酸がありません。    "}),e.add({id:43,href:"/Mjolnir/ja/docs/reference/forcefields/external/PullingForceInteraction/",title:"PullingForce",section:"External",content:"PullingForce #  指定した粒子に一定の力をかけ続けます。\n例 #  [[forcefields.external]] interaction = \u0026#34;PullingForce\u0026#34; parameters = [  {index = 0, force = [1.0, 0.0, 0.0]},  {index = 0, force = 1.0, direction = [1.0, 1.0, 1.0]},  # ... ] 入力 #   interaction: 文字列型  相互作用の名前です。ここでは、\u0026quot;PullingForce\u0026quot;です。   parameters: テーブル型  index: 整数型  力をかける粒子のインデックスです。インデックスは0始まりです。   force: 浮動小数点数型または浮動小数点数の配列型  浮動小数点数の配列型が与えられた場合、力そのものを表します。 浮動小数点数型が与えられた場合、力の強さを表します。その場合、directionを与える必要があります。 単位は[units]で指定した単位系に従います（例えば、 kcal/mol/Å）.  1 kcal/mol/Å ~ 69.5 pN.     direction: 浮動小数点数の配列型  力の向きです。強さはforceで与えられるので、読み込まれたのち規格化されます。      "}),e.add({id:44,href:"/Mjolnir/ja/docs/reference/forcefields/external/CoMPullingForceInteraction/",title:"CoMPullingForce",section:"External",content:"CoMPullingForce #  指定した複数の粒子の重心に対して力をかけ続けます。力は重み付けされて各粒子に分散されます。\n例 #  [[forcefields.external]] interaction = \u0026#34;CoMPullingForce\u0026#34; parameters = [  {indices = [0, 1, 2], force = [0.0, 0.0, 0.0144]},  {indices = \u0026#34;[0, 10)\u0026#34;, force = 0.0144, direction = [1.0, 1.0, 1.0]},  {indices = [\u0026#34;[0, 99]\u0026#34;, \u0026#34;[200, 300)\u0026#34;], force = 0.0144, direction = [1.0, 1.0, 1.0]},  # ... ] 入力 #   interaction: 文字列型  相互作用の名前です。ここでは、\u0026quot;CoMPullingForce\u0026quot;です。   parameters: テーブル型  index: 整数型 indices: 整数型の配列、文字列、または文字列型の配列  力をかける粒子のインデックスです。インデックスは0始まりです。 整数型の配列が与えられた場合、それらがそのままインデックスとなります。 文字列が与えられた場合、区間として解釈されます。 \u0026quot;[0, 10)\u0026quot;は0から9までの半開区間と解釈されます。 文字列の配列が与えられた場合、それぞれの区間が結合されます。 粒子のインデックスにオーバーラップがあった場合、それは解消されユニークになります。   force: 浮動小数点数型または浮動小数点数の配列型  浮動小数点数の配列型が与えられた場合、力そのものを表します。 浮動小数点数型が与えられた場合、力の強さを表します。その場合、directionを与える必要があります。 単位は[units]で指定した単位系に従います（例えば、 kcal/mol/Å）.  1 kcal/mol/Å ~ 69.5 pN.     direction: 浮動小数点数の配列型  力の向きです。強さはforceで与えられるので、読み込まれたのち規格化されます。      "}),e.add({id:45,href:"/Mjolnir/ja/docs/reference/forcefields/local/DummyInteraction/",title:"Dummy",section:"Local",content:"DummyInteraction #  Dummy相互作用は、何も計算しない相互作用です。利用可能なポテンシャルはありません。\nこれは、力場に必要な相互作用だけでは表現できないようなトポロジーを表現するために 用いることができます。つまり、これを使うと、実際には直接の相互作用がないような 粒子のペアに対して結合を加え、それを基準にnonbondedな相互作用に影響を与えること ができます。\nトポロジーを指定しなかった（\u0026quot;none\u0026quot;にした）場合、この相互作用には何の意味も なくなります。\nトポロジーの効果については、Topologyを参照して下さい。\n例 #  [[forcefields.local]] interaction = \u0026#34;Dummy\u0026#34; # No potential field required. topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], offset = 100}, # No other parameters.  # ... ] 入力 #   interaction: String  相互作用の名前です。\u0026quot;Dummy\u0026quot;を指定します。   topology: 文字列型  \u0026quot;Topology\u0026quot;に設定する名前を指定します。   parameters: テーブルの配列型  indices: 整数の配列型（長さ: 2）  どの粒子の間の距離に適用するかを指定します。最初の粒子は0番目です。   offset: 整数型(省略可能)  indicesに加算する値です。省略可能です。グループ内番号を使いたい場合に便利です。   ポテンシャルがないので、他のパラメータはありません。    "}),e.add({id:46,href:"/Mjolnir/ja/docs/reference/forcefields/local/dihedral/CosinePotential/",title:"Cosine",section:"DihedralAngle",content:"CosinePotential #  HarmonicよりもDihedralAngleで用いやすい、周期的なポテンシャルです。\n  \\[U(v) = k\\left(1 \u0026#43; \\cos(n(v - v_0))\\right)\\]  例 #  [[forcefields.local]] interaction = \u0026#34;DihedralAngle\u0026#34; potential = \u0026#34;Cosine\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1, 2, 3], v0 = 1.57, k = 10.0, n = 1}, ] 入力 #   k: 浮動小数点数型  このポテンシャルの強さを指定します。   n: 整数  谷の個数を決めます。   v0: 浮動小数点数  谷の位置を決めます。   indices: 整数の配列型（長さ: 4）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:47,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondangle/HarmonicPotential/",title:"Harmonic",section:"BondAngle",content:"HarmonicPotential #  シンプルで、様々な用途で用いられる調和振動子ポテンシャルです。\n  \\[U(v) = k(v-v_0)^2\\]  例 #  [[forcefields.local]] interaction = \u0026#34;BondAngle\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1, 2], offset = 100, v0 = 1.0, k = 100.0},  # ... ] 入力 #   k: 浮動小数点数型  ポテンシャルの強さを指定します。   v0: 浮動小数点数型  最安定点を指定します。   indices: 整数の配列型（長さ:3）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:48,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondlength/HarmonicPotential/",title:"Harmonic",section:"BondLength",content:"HarmonicPotential #  シンプルで、様々な用途で用いられる調和振動子ポテンシャルです。\n  \\[U(v) = k(v-v_0)^2\\]  例 #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Harmonic\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], offset = 100, v0 = 1.0, k = 100.0},  # ... ] 入力 #   k: 浮動小数点数型  ポテンシャルの強さを指定します。   v0: 浮動小数点数型  最安定点を指定します。   indices: 整数の配列型（長さ:2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:49,href:"/Mjolnir/ja/docs/reference/forcefields/external/distance/LennardJonesWallPotential/",title:"LennardJones",section:"Distance",content:"LennardJonesWallPotential #  よく知られたLennard-Jonesポテンシャルです。\n  \\[U(r) = 4\\epsilon\\left(\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right)\\]  例 #  [[forcefields.external]] interaction = \u0026#34;Distance\u0026#34; potential = \u0026#34;LennardJonesWall\u0026#34; shape.name = \u0026#34;AxisAlignedPlane\u0026#34; shape.axis = \u0026#34;X\u0026#34; shape.position = 0.0 shape.margin = 0.5  parameters = [  {index = 0, sigma = 1.0, epsilon = 0.1},  # ... ] 入力 #   epsilon: 浮動小数点数  ポテンシャルの強さを決めます。   sigma: 浮動小数点数  粒子のサイズを決めます。    "}),e.add({id:50,href:"/Mjolnir/ja/docs/reference/forcefields/external/rectangularbox/LennardJonesWallPotential/",title:"LennardJones",section:"RectangularBox",content:"LennardJonesWallPotential #  よく知られたLennard-Jonesポテンシャルです。\n  \\[U(r) = 4\\epsilon\\left(\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right)\\]  例 #  [[forcefields.external]] interaction = \u0026#34;RectangularBox\u0026#34; box.lower = [ 0.0, 0.0, 0.0] box.upper = [100.0, 100.0, 100.0] box.margin = 0.4  potential = \u0026#34;LennardJonesWall\u0026#34; parameters = [  {index = 0, sigma = 1.0, epsilon = 0.1},  # ... ] 入力 #   epsilon: 浮動小数点数  ポテンシャルの強さを決めます。   sigma: 浮動小数点数  粒子のサイズを決めます。    "}),e.add({id:51,href:"/Mjolnir/ja/docs/reference/forcefields/global/pair/LennardJonesPotential/",title:"LennardJones",section:"Pair",content:"LennardJonesPotential #  よく知られたLennard-Jonesポテンシャルです。\n  \\[U(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]  例 #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJones\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2}  cutoff = 2.5 parameters = [  {index = 0, offset = 100, sigma = 2.0, epsilon = 10.0}, ] 入力 #   \\( \\sigma \\)  と  \\( \\epsilon \\)  の計算には、Lorentz-Berthelot則が用いられます。\n \\[\\sigma_{ij} = \\frac{\\sigma_i \u0026#43; \\sigma_j}{2} \\\\ \\epsilon_{ij} = \\sqrt{\\epsilon_i\\epsilon_j}\\]   index: 整数型  粒子の番号です。最初の粒子は0番目です。   offset: 整数型（省略可能）  番号のオフセットです。省略可能です。グループ内番号などを使う際に便利です。   sigma: 浮動小数点数型  粒子のサイズを指定します。   epsilon: 浮動小数点数型  ポテンシャルの強さを指定します。   cutoff: 浮動小数点数型（省略可能）  カットオフ長です。 \\(\\sigma_{ij}\\)  に相対です。    入力の他の部分は、Pairを参照してください。\n"}),e.add({id:52,href:"/Mjolnir/ja/docs/reference/forcefields/external/distance/ExcludedVolumeWallPotential/",title:"ExcludedVolume",section:"Distance",content:"ExcludedVolumeWallPotential #  排除体積相互作用のポテンシャルです。\n  \\[U(r) = \\epsilon\\left(\\frac{r_0}{r}\\right)^{12}\\]  例 #  [[forcefields.external]] interaction = \u0026#34;Distance\u0026#34; potential = \u0026#34;ExcludedVolumeWall\u0026#34; shape.name = \u0026#34;AxisAlignedPlane\u0026#34; shape.axis = \u0026#34;X\u0026#34; shape.position = 0.0 shape.margin = 0.5  epsilon = 0.5 parameters = [  {index = 0, radius = 1.0},  # ... ] 入力 #   epsilon: 浮動小数点数型  ポテンシャルの強さを決めます。   radius: 浮動小数点数型  粒子の半径を決めます。    "}),e.add({id:53,href:"/Mjolnir/ja/docs/reference/forcefields/external/rectangularbox/ExcludedVolumeWallPotential/",title:"ExcludedVolume",section:"RectangularBox",content:"ExcludedVolumeWallPotential #  排除体積相互作用のポテンシャルです。\n  \\[U(r) = \\epsilon\\left(\\frac{r_0}{r}\\right)^{12}\\]  例 #  [[forcefields.external]] interaction = \u0026#34;RectangularBox\u0026#34; box.lower = [ 0.0, 0.0, 0.0] box.upper = [100.0, 100.0, 100.0] box.margin = 0.4  potential = \u0026#34;LennardJonesWall\u0026#34; epsilon = 0.5 parameters = [  {index = 0, radius = 1.0},  # ... ] 入力 #   epsilon: 浮動小数点数型  ポテンシャルの強さを決めます。   radius: 浮動小数点数型  粒子の半径を決めます。    "}),e.add({id:54,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondangle/GaussianPotential/",title:"Gaussian",section:"BondAngle",content:"GaussianPotential #  ガウシアンポテンシャルは以下のような形のポテンシャルです。\n  \\[U(v) = k\\exp\\left(\\frac{-(v - v_0)^2}{2\\sigma^2}\\right)\\]  例 #  [[forcefields.local]] interaction = \u0026#34;BondAngle\u0026#34; potential = \u0026#34;Gaussian\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1, 2], v0 = 1.0, k = -100.0, sigma = 5.0},  # ... ] 入力 #   k: 浮動小数点数型  ポテンシャルの強さを指定します。   sigma: 浮動小数点数型  ポテンシャルが効果を及ぼす幅を指定します。   v0: 浮動小数点数型  最安定点を指定します。   indices: 整数の配列型（長さ:3）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:55,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondlength/GaussianPotential/",title:"Gaussian",section:"BondLength",content:"GaussianPotential #  ガウシアンポテンシャルは以下のような形のポテンシャルです。\n  \\[U(v) = k\\exp\\left(\\frac{-(v - v_0)^2}{2\\sigma^2}\\right)\\]  例 #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;Gaussian\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = -100.0, sigma = 5.0},  # ... ] 入力 #   k: 浮動小数点数型  ポテンシャルの強さを指定します。   sigma: 浮動小数点数型  ポテンシャルが効果を及ぼす幅を指定します。   v0: 浮動小数点数型  最安定点を指定します。   indices: 整数の配列型（長さ:2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:56,href:"/Mjolnir/ja/docs/reference/forcefields/local/contact/GaussianPotential/",title:"Gaussian",section:"Contact",content:"GaussianPotential #  ガウシアンポテンシャルは以下のような形のポテンシャルです。\n  \\[U(v) = k\\exp\\left(\\frac{-(v - v_0)^2}{2\\sigma^2}\\right)\\]  例 #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;Gaussian\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = -100.0, sigma = 5.0},  # ... ] 入力 #   k: 浮動小数点数型  ポテンシャルの強さを指定します。   sigma: 浮動小数点数型  ポテンシャルが効果を及ぼす幅を指定します。   v0: 浮動小数点数型  最安定点を指定します。   indices: 整数の配列型（長さ:2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:57,href:"/Mjolnir/ja/docs/reference/forcefields/local/dihedral/GaussianPotential/",title:"Gaussian",section:"DihedralAngle",content:"GaussianPotential #  ガウシアンポテンシャルは以下のような形のポテンシャルです。\n  \\[U(v) = k\\exp\\left(\\frac{-(v - v_0)^2}{2\\sigma^2}\\right)\\]  例 #  [[forcefields.local]] interaction = \u0026#34;DihedralAngle\u0026#34; potential = \u0026#34;Gaussian\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1, 2, 3], v0 = 1.0, k = -100.0, sigma = 5.0},  # ... ] 入力 #   k: 浮動小数点数型  ポテンシャルの強さを指定します。   sigma: 浮動小数点数型  ポテンシャルが効果を及ぼす幅を指定します。   v0: 浮動小数点数型  最安定点を指定します。   indices: 整数の配列型（長さ:4）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:58,href:"/Mjolnir/ja/docs/reference/forcefields/global/pair/UniformLennardJonesPotential/",title:"UniformLennardJones",section:"Pair",content:"UniformLennardJonesPotential #  よく知られたLennard-Jonesポテンシャルです。\n  \\[U(r) = 4\\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\]  全ての粒子が同じパラメータを持っている場合のためのポテンシャルです。\n例 #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;UniformLennardJones\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2}  cutoff = 2.5 sigma = 2.0 epsilon = 0.5 parameters = [  {index = 0, offset = 100}, # to control which particle participates ] 入力 #   index: 整数型  粒子の番号です。最初の粒子は0番目です。   offset: 整数型（省略可能）  番号のオフセットです。省略可能です。グループ内番号などを使う際に便利です。   sigma: 浮動小数点数型  粒子のサイズを指定します。   epsilon: 浮動小数点数型  ポテンシャルの強さを指定します。   cutoff: 浮動小数点数型（省略可能）  カットオフ長です。 \\(\\sigma_{ij}\\)  に相対です。    入力の他の部分は、Pairを参照してください。\n"}),e.add({id:59,href:"/Mjolnir/ja/docs/reference/forcefields/global/pair/DebyeHuckelPotential/",title:"DebyeHückel",section:"Pair",content:"DebyeHückelPotential #  Debye-Hückelの式に基づいた、イオン溶液内での静電相互作用のモデルです。\n  \\[U(r_{ij}) = \\frac{q_i q_j}{4\\pi\\epsilon_0\\epsilon_k r_{ij}} \\exp(-r_{ij}/\\lambda_D)\\]   \\[\\lambda_D = \\sqrt{\\frac{\\epsilon_0\\epsilon_k}{2\\beta N_A e_c^2 I}}\\]  温度・イオン強度に依存した水の電気伝導度は以下の論文の式に従います。\n Sambriski, E. J. et al., (2009) Biophys. J. Hinckley, D. M. et al., (2013) JCP. Freeman, G. S., et al., (2014) JCP.  例 #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;DebyeHuckel\u0026#34; ignore.particles_within.bond = 3 spatial_partition.type = \u0026#34;CellList\u0026#34; spatial_partition.margin = 0.2 cutoff = 5.5 parameters = [  {index = 0, charge = 1.0}, ] 入力 #  このポテンシャルは、system attributeでtemperatureと ionic_strengthを設定していることを要求します。\n cutoff: 浮動小数点数型（省略可能。デフォルトでは5.5）  カットオフ長です。デバイ長との相対です。   index: 整数型  粒子の番号です。最初の粒子は0番目です。   offset: 整数型（省略可能）  番号のオフセットです。省略可能です。グループ内番号などを使う際に便利です。   charge: 浮動小数点数型  粒子の電荷です。    入力の他の部分は、Pairを参照してください。\n"}),e.add({id:60,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondangle/FlexibleLocalAnglePotential/",title:"FlexibleLocal",section:"BondAngle",content:"FlexibleLocalAngle #  粗視化タンパク質モデルで、フレキシブル領域の角度分布を再現するためのポテンシャルです。 角度分布を再現するため、値の表を内挿したものとして定義されています。\nAICG2+粗視化タンパク質力場の一部として使われることが多いです。\n以下の論文で開発されました。\n T. Terakawa and S. Takada, (2011) Biophys J.  例 #  [[forcefields.local]] interaction = \u0026#34;BondAngle\u0026#34; potential = \u0026#34;FlexibleLocalAngle\u0026#34; topology = \u0026#34;none\u0026#34; env.x = [ 1.3090, 1.4835, 1.6581, 1.8326, 2.0071, 2.1817, 2.3562, 2.5307, 2.7053, 2.8798] env.y1_ALA = [ 5.00, 1.34, 0.84, 1.17, 0.82, 1.00, 1.27, 1.52, 3.20, 10.00] env.y2_ALA = [ 0.00, 151.96, 14.61, -46.89, 39.04, -4.86, -1.86, 8.38, 250.03, 0.00] parameters = [  {indices = [0, 1, 2], k = 1.0, x = \u0026#34;x\u0026#34;, y = \u0026#34;y1_ALA\u0026#34;, d2y = \u0026#34;y2_ALA\u0026#34;},  # ... ] 入力 #   k: 浮動小数点数型  このポテンシャルの強さを指定します。   x: 浮動小数点数の配列型（省略可能・長さ:10）  どの角度でyデータを与えるかを指定します。誤差程度の範囲で概ね等間隔であることが要求されます。 省略した場合、AICG2+でのデフォルトの値になります。   y: 浮動小数点数の配列型（長さ: 10）  角度ごとのエネルギーの値を指定します。   d2y: 浮動小数点数の配列型（長さ: 10）  角度ごとのエネルギーの2回微分の値を指定します。   indices: 整数の配列型（長さ: 3）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:61,href:"/Mjolnir/ja/docs/reference/forcefields/local/dihedral/FlexibleLocalDihedralPotential/",title:"FlexibleLocal",section:"DihedralAngle",content:"FlexibleLocalDihedral #  粗視化タンパク質モデルで、フレキシブル領域の角度分布を再現するためのポテンシャルです。 角度分布を再現するため、フーリエ級数展開の形で定義されています。\n  \\[U(\\phi) = C \u0026#43; \\sum_{n=1}^{3}\\left( k_n^{\\sin} \\sin(n\\phi) \u0026#43; k_n^{\\cos} \\cos(n\\phi)\\right)\\]  AICG2+粗視化タンパク質力場の一部として使われることが多いです。\n以下の論文で開発されました。\n T. Terakawa and S. Takada, (2011) Biophys J  例 #  [[forcefields.local]] parameters = [  {indices = [0,1,2,3], k = 1.0, coef = [2.2356, 0.4119, -0.1283, 0.0229, -0.2708, -0.0085, -0.0641]},  # ... ] 入力 #   k: 浮動小数点数型  このポテンシャルの強さを指定します。   coef: 浮動小数点数の配列型（長さ: 7）  前から順に、 \\( C, k_1^{\\sin}, k_1^{\\cos}, k_2^{\\sin}, k_2^{\\cos}, k_3^{\\sin}, k_3^{\\cos} \\)  です。   indices: 整数の配列型（長さ: 4）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:62,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondlength/GoContactPotential/",title:"GoContact",section:"BondLength",content:"GoContactPotential #  Go-コンタクトポテンシャルは以下のような形のポテンシャルです。\n  \\[U(r) = k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right]\\]  粗視化分子動力学の構造依拠モデルで、参照構造で距離が近かった粒子同士のコンタクトとして用いられるポテンシャルです。\n例 #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;GoContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] 入力 #   v0: 浮動小数点数型  最安定距離を指定します。   k: 浮動小数点数型  パラメータの強さを指定します。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:63,href:"/Mjolnir/ja/docs/reference/forcefields/local/contact/GoContactPotential/",title:"GoContact",section:"Contact",content:"GoContactPotential #  Go-コンタクトポテンシャルは以下のような形のポテンシャルです。\n  \\[U(r) = k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right]\\]  粗視化分子動力学の構造依拠モデルで、参照構造で距離が近かった粒子同士のコンタクトとして用いられるポテンシャルです。\n例 #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;GoContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] 入力 #   v0: 浮動小数点数型  最安定距離を指定します。   k: 浮動小数点数型  パラメータの強さを指定します。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:64,href:"/Mjolnir/ja/docs/reference/forcefields/external/distance/ImplicitMembranePotential/",title:"ImplicitMembrane",section:"Distance",content:"ImplicitMembranePotential #  平面の周りにある粒子をその疎水度に応じて安定化するimplicitな膜モデルです。\n  \\[U(\\mathbf{r}) = \\sum_i^N k h_i \\tanh\\left(\\mathrm{bend} * \\left(|z_i - z_0| - \\frac{\\mathrm{thickness}}{2}\\right)\\right)\\]  例 #  [[forcefields.external]] interaction = \u0026#34;Distance\u0026#34; potential = \u0026#34;ImplicitMembrane\u0026#34; shape.name = \u0026#34;AxisAlignedPlane\u0026#34; shape.axis = \u0026#34;X\u0026#34; shape.position = 0.0 shape.margin = 0.5  bend = 1.0 thickness = 4.0 interaction_magnitude = 10.0 parameters = [  {index = 0, hydrophobicity = 1.0},  # ... ] 入力 #   bend: 浮動小数点数  中央の安定化を受ける部分と外側の部分との間のスロープの傾きを決めます。   thickness: 浮動小数点数  中央の安定化を受ける部分の幅を決めます。   interaction_magnitude: 浮動小数点数  ポテンシャルの強さを決めます。上式の \\( k \\)  です。   parameters: テーブルの配列型  index: 整数型  粒子の番号です。最初の粒子は0番目です。   hydrophobicity: 浮動小数点数型  粒子の疎水度です。上式の \\( h \\)  です。      Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:65,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondlength/AttractiveGoContact/",title:"AttractiveGo",section:"BondLength",content:"AttractiveGoContactPotential #  Go-Contact potentialの引力項です。\n  \\[U(r) = \\begin{cases} -k \u0026amp; (r \u0026lt; r_0) \\\\ k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right] \u0026amp; otherwise \\end{cases}\\]  例 #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;AttractiveGoContact\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] 入力 #   v0: 浮動小数点数型  最安定距離を指定します。   k: 浮動小数点数型  パラメータの強さを指定します。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:66,href:"/Mjolnir/ja/docs/reference/forcefields/local/contact/AttractiveGoContact/",title:"AttractiveGo",section:"Contact",content:"AttractiveGoContactPotential #  Go-Contact potentialの引力項です。\n  \\[U(r) = \\begin{cases} -k \u0026amp; (r \u0026lt; r_0) \\\\ k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right] \u0026amp; otherwise \\end{cases}\\]  例 #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;AttractiveGoContact\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] 入力 #   v0: 浮動小数点数型  最安定距離を指定します。   k: 浮動小数点数型  パラメータの強さを指定します。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:67,href:"/Mjolnir/ja/docs/reference/forcefields/local/dihedral/ClementiDihedralPotential/",title:"ClementiDihedral",section:"DihedralAngle",content:"ClementiDihedral #  ClementiらによるOff-lattice Goモデルで使用されたポテンシャルです。\n  \\[U(v) = k_1(1-\\cos(v-v_0)) \u0026#43; k_3(1-\\cos(3(v-v_0)))\\]  以下の論文で提案されました。\n C. Clementi, H. Nymeyer, J. Onuchic, (2000) JMB  例 #  [[forcefields.local]] interaction = \u0026#34;DihedralAngle\u0026#34; potential = \u0026#34;ClementiDihedral\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0,1,2,3], v0 = -2.20, k1 = 1.0, k3 = 0.5},  # ... ] 入力 #   v0: 浮動小数点数型  ポテンシャルの最安定点を決めます。   k1: 浮動小数点数型  このポテンシャルの強さを指定します。   k3: 浮動小数点数型  このポテンシャルの強さを指定します。   indices: 整数の配列型（長さ: 4）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:68,href:"/Mjolnir/ja/docs/reference/forcefields/global/pair/ExcludedVolumePotential/",title:"ExcludedVolume",section:"Pair",content:"ExcludedVolume #  排除体積効果のポテンシャルです。\n  \\[U(r) = \\epsilon\\left(\\frac{\\sigma}{r}\\right)^{12}\\]  例 #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;ExcludedVolume\u0026#34;  ignore.particles_within.bond = 3 ignore.particles_within.contact = 1  spatial_partition.type = \u0026#34;CellList\u0026#34; spatial_partition.margin = 0.2  cutoff = 2.5 epsilon = 0.2 parameters = [  {index = 0, radius = 2.0} ] 入力 #   epsilon: 浮動小数点数型  ポテンシャルの強さを指定します。   index: 整数型  粒子のインデックスを指定します。   offset: 整数型（省略可能）  インデックスのオフセットを指定します。   radius: 浮動小数点数型  粒子のサイズを指定します。 粒子ペアでの \\( \\sigma \\)  はradiusの和になります。   cutoff: 浮動小数点数型（省略可能）  カットオフ長です。 \\(\\sigma_{ij}\\)  に相対です。    入力の他の部分は、Pairを参照してください。\n"}),e.add({id:69,href:"/Mjolnir/ja/docs/reference/forcefields/global/pair/InversePowerPotential/",title:"InversePower",section:"Pair",content:"InversePowerPotential #  Excluded Volumeポテンシャルの一般的な形です。\n  \\[U(r) = \\epsilon\\left(\\frac{\\sigma}{r}\\right)^{n}\\]  例 #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;InversePower\u0026#34;  ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 ignore.groups.intra = [\u0026#34;chain-A\u0026#34;] ignore.groups.inter = [[\u0026#34;chain-B\u0026#34;, \u0026#34;chain-C\u0026#34;]]  spatial_partition.type = \u0026#34;CellList\u0026#34; spatial_partition.margin = 0.2  cutoff = 2.5 epsilon = 0.2 n = 5 parameters = [  {index = 0, radius = 2.0} ] 入力 #   cutoff: 浮動小数点数型（省略可能。デフォルトで、 \\(2^{\\frac{12}{n}}\\)  ）  カットオフ長です。 \\( \\sigma_{ij} \\)  との相対です。   epsilon: 浮動小数点数型  ポテンシャルの強さを決めます。   n: 整数型  ポテンシャルの傾きを決めます。   index: 整数型  粒子の番号です。最初の粒子は0番目です。   offset: 整数型（省略可能）  番号のオフセットです。省略可能です。グループ内番号などを使う際に便利です。   radius: 浮動小数点数型  粒子のサイズを決めます。 粒子ペアでの \\( \\sigma \\)  はradiusの和になります。    Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:70,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondlength/RepulsiveGoContact/",title:"RepulsiveGo",section:"BondLength",content:"RepulsiveGoContactPotential #  Go-Contact potentialの斥力項です。\n  \\[U(r) = \\begin{cases} k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10} \u0026#43; 1\\right] \u0026amp; r \u0026lt; r_0 \\\\ 0 \u0026amp; otherwise \\end{cases}\\]  例 #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;RepulsiveGoContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] 入力 #   v0: 浮動小数点数型  最安定距離を指定します。   k: 浮動小数点数型  パラメータの強さを指定します。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:71,href:"/Mjolnir/ja/docs/reference/forcefields/local/contact/RepulsiveGoContact/",title:"RepulsiveGo",section:"Contact",content:"RepulsiveGoContactPotential #  Go-Contact potentialの斥力項です。\n  \\[U(r) = \\begin{cases} k\\left[5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10} \u0026#43; 1\\right] \u0026amp; r \u0026lt; r_0 \\\\ 0 \u0026amp; otherwise \\end{cases}\\]  例 #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;RepulsiveGoContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] 入力 #   v0: 浮動小数点数型  最安定距離を指定します。   k: 浮動小数点数型  パラメータの強さを指定します。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:72,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondlength/AttractiveMBasinContact/",title:"AttractiveMBasin",section:"BondLength",content:"AttractiveMBasinContactPotential #  MultipleBasin力場で用いられる、Go-Contact potentialの引力項です。\n  \\[U(r) = k\\min\\left(0, 5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right)\\]  例 #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;AttractiveMBasinContact\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] 入力 #   v0: 浮動小数点数型  最安定距離を指定します。   k: 浮動小数点数型  パラメータの強さを指定します。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:73,href:"/Mjolnir/ja/docs/reference/forcefields/local/contact/AttractiveMBasinContact/",title:"AttractiveMBasin",section:"Contact",content:"AttractiveMBasinContactPotential #  MultipleBasin力場で用いられる、Go-Contact potentialの引力項です。\n  \\[U(r) = k\\min\\left(0, 5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10}\\right)\\]  例 #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;AttractiveMBasinContact\u0026#34; topology = \u0026#34;none\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] 入力 #   v0: 浮動小数点数型  最安定距離を指定します。   k: 浮動小数点数型  パラメータの強さを指定します。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:74,href:"/Mjolnir/ja/docs/reference/forcefields/global/pair/HardCoreExcludedVolumePotential/",title:"HardCore",section:"Pair",content:"HardCoreExcludedVolume #  中心に重なり合わない硬い核を持つ排除体積ポテンシャルです。\n  \\[U(r) = \\epsilon\\left(\\frac{\\sigma}{r - r_0}\\right)^{12}\\]  例 #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;HardCoreExcludedVolume\u0026#34;  ignore.particles_within.bond = 3 ignore.particles_within.contact = 1  spatial_partition.type = \u0026#34;CellList\u0026#34; spatial_partition.margin = 0.2  cutoff = 2.5 epsilon = 0.2 parameters = [  {index = 0, core_radius = 3.0, soft_shell_thickness = 2.0},  {index = 1, core_radius = 3.0, soft_shell_thickness = 2.0}, ] 入力 #   epsilon: 浮動小数点数型  ポテンシャルの強さを指定します。   index: 整数型  粒子のインデックスを指定します。   offset: 整数型（省略可能）  インデックスのオフセットを指定します。   core_radius: 浮動小数点数型  核の半径です。上の式での \\( r_0 \\)  に相当します。 粒子ペアでの \\( r_0 \\)  はcore_radiusの和になります。   soft_shell_thickness: 浮動小数点数型  核の外側の半径です。上の式での \\( \\sigma \\)  に相当します。 粒子ペアでの \\(\\sigma_{ij}\\)  はsoft_shell_thicknessの和になります。   cutoff: 浮動小数点数型（省略可能）  カットオフ長です。 \\(\\sigma_{ij}\\)  に相対です。    Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:75,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondlength/RepulsiveMBasinContact/",title:"RepulsiveMBasin",section:"BondLength",content:"RepulsiveMBasinContactPotential #  MultipleBasin力場で用いられる、Go-Contact potentialの斥力項です。\n  \\[U(r) = k\\max\\left(0, 5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10})\\]  例 #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;RepulsiveMBasinContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] 入力 #   v0: 浮動小数点数型  最安定距離を指定します。   k: 浮動小数点数型  パラメータの強さを指定します。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:76,href:"/Mjolnir/ja/docs/reference/forcefields/local/contact/RepulsiveMBasinContact/",title:"RepulsiveMBasin",section:"Contact",content:"RepulsiveMBasinContactPotential #  MultipleBasin力場で用いられる、Go-Contact potentialの斥力項です。\n  \\[U(r) = k\\max\\left(0, 5\\left(\\frac{r_0}{r}\\right)^{12} - 6\\left(\\frac{r_0}{r}\\right)^{10})\\]  例 #  [[forcefields.local]] interaction = \u0026#34;Contact\u0026#34; potential = \u0026#34;RepulsiveMBasinContact\u0026#34; topology = \u0026#34;contact\u0026#34; parameters = [  {indices = [0, 1], v0 = 1.0, k = 0.1},  # ... ] 入力 #   v0: 浮動小数点数型  最安定距離を指定します。   k: 浮動小数点数型  パラメータの強さを指定します。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:77,href:"/Mjolnir/ja/docs/reference/forcefields/global/pair/WCAPotential/",title:"WCA",section:"Pair",content:"WCAPotential #  よく知られたWCA (Weeks-Chandler-Andersen) ポテンシャルです。Lennard-Jonesの斥力項のみを取り出した形のポテンシャルです。\n  \\[U(r) = \\begin{cases} 4\\epsilon \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6\\right] \u0026#43; \\epsilon \u0026amp; (r \u0026lt; \\sigma_{ij}\\sqrt[6]{2})\\\\ 0 \u0026amp; (r \\geq \\sigma_{ij}\\sqrt[6]{2})\\\\ \\end{cases}\\]  例 #  パラメータを指定するには二通りの方法があります。\n個々の粒子のパラメータを指定し、Lorentz-Berthelot則でペアのパラメータを計算する方法と、\n[[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;WCA\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2}  parameters = [  {index = 0, offset = 100, sigma = 2.0, epsilon = 10.0}, ] 粒子の名前を指定し、表でペアのパラメータを与える方法があります。\n[[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJonesAttractive\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2}  table.A.A = {sigma = 1.0, epsilon = 2.0} table.A.B = {sigma = 3.0, epsilon = 1.0} # B.A will be the same table.B.B = {sigma = 1.0, epsilon = 1.5} parameters = [  {index = 0, offset = 100, name = \u0026#34;A\u0026#34;},  {index = 1, offset = 100, name = \u0026#34;B\u0026#34;},  # ... ] 入力 #   index: 整数型  粒子の番号です。最初の粒子は0番目です。   offset: 整数型（省略可能）  番号のオフセットです。省略可能です。グループ内番号などを使う際に便利です。   sigma: 浮動小数点数型  粒子のサイズを指定します。テーブルを用意する場合、これは不要です。   epsilon: 浮動小数点数型  ポテンシャルの強さを指定します。テーブルを用意する場合、これは不要です。   name: 文字列型  粒子の名前です。テーブルを用意する場合、これは必須です。    このポテンシャルは \\( r = \\sigma\\sqrt[6]{2} \\)  で正確に0となるため、カットオフには常にこの値が使用されます。 よって、cutoffを指定する必要はありません。\n入力の他の部分は、Pairを参照してください。\n"}),e.add({id:78,href:"/Mjolnir/ja/docs/reference/forcefields/global/pair/LennardJonesAttractivePotential/",title:"LennardJonesAttractive",section:"Pair",content:"LennardJonesAttractivePotential #  Lennard-Jonesポテンシャルの引力項のみを取り出した形のポテンシャルです。\n  \\[U(r) = \\begin{cases} -\\epsilon \u0026amp; (r \u0026lt; \\sigma_{ij}\\sqrt[6]{2})\\\\ 4\\epsilon \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6\\right] \u0026#43; \\epsilon \u0026amp; (\\sigma_{ij}\\sqrt[6]{2} \u0026lt; r) \\end{cases}\\]  例 #  パラメータを指定するには二通りの方法があります。\n個々の粒子のパラメータを指定し、Lorentz-Berthelot則でペアのパラメータを計算する方法と、\n[[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJonesAttractive\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2}  cutoff = 2.5 parameters = [  {index = 0, offset = 100, sigma = 2.0, epsilon = 10.0}, ] 粒子の名前を指定し、表でペアのパラメータを与える方法があります。\n[[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;LennardJonesAttractive\u0026#34; ignore.molecule = \u0026#34;Nothing\u0026#34; ignore.particles_within.bond = 3 ignore.particles_within.contact = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.2}  cutoff = 2.5 table.A.A = {sigma = 1.0, epsilon = 2.0} table.A.B = {sigma = 3.0, epsilon = 1.0} # B.A will be the same table.B.B = {sigma = 1.0, epsilon = 1.5} parameters = [  {index = 0, offset = 100, name = \u0026#34;A\u0026#34;},  {index = 1, offset = 100, name = \u0026#34;B\u0026#34;},  # ... ] 入力 #   index: 整数型  粒子の番号です。最初の粒子は0番目です。   offset: 整数型（省略可能）  番号のオフセットです。省略可能です。グループ内番号などを使う際に便利です。   sigma: 浮動小数点数型  粒子のサイズを指定します。テーブルを用意する場合、これは不要です。   epsilon: 浮動小数点数型  ポテンシャルの強さを指定します。テーブルを用意する場合、これは不要です。   name: 文字列型  粒子の名前です。テーブルを用意する場合、これは必須です。    入力の他の部分は、Pairを参照してください。\n"}),e.add({id:79,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondlength/WormLikeChainPotential/",title:"WormLikeChain",section:"BondLength",content:"WormLikeChain #  Worm-Like chain modelに基づいたポテンシャルです。\n  \\[U(r) = \\frac{k_B T}{p} \\left(\\frac{l_c}{4} \\left[ \\frac{1}{1 - \\frac{r}{l_c}} - 1 \\right] - \\frac{r}{4} \u0026#43; \\frac{r^2}{2l_c}\\right)\\]  例 #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;WormLikeChain\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], offset = 100, p = 5.0, lc = 100.0},  # ... ] 入力 #   p: 浮動小数点数型  ポリマーの持続長です。   lc: 浮動小数点数型  ポリマーの最大長です。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:80,href:"/Mjolnir/ja/docs/reference/forcefields/global/pair/iSoLFAttractivePotential/",title:"iSoLF",section:"Pair",content:"iSoLFAttractivePotential #  iSoLFは以下の文献で開発された粗視化膜モデルで、iSoLFAttractiveはその引力ポテンシャルです。\n Diego Ugarte La Torre and Shoji Takada (2020) J. Chem. Phys 153, 205101 https://doi.org/10.1063/5.0026342    \\[U(r) = \\begin{cases} -\\epsilon_{ij} \u0026amp; r_{ij} \u0026lt; \\sqrt[6]{2}\\sigma_{ij}\\\\ -\\epsilon_{ij} \\cos^2\\left[\\frac{\\pi}{2\\omega_{ij}}(r_{ij} - \\sqrt[6]{2}\\sigma_{ij}) \\right] \u0026amp; (\\sqrt[6]{2}\\sigma_{ij} \u0026lt; r_{ij} \u0026lt; \\sqrt[6]{2}\\sigma_{ij} \u0026#43; \\omega_{ij})\\\\ 0 \u0026amp; (\\sqrt[6]{2}\\sigma_{ij} \u0026#43; \\omega_{ij} \u0026lt; r_{ij}) \\end{cases}\\]  例 #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;iSoLFAttractive\u0026#34; ignore.particles_within = {bond = 1, angle = 1} ignore.group.inter = [  [\u0026#34;T1\u0026#34;, \u0026#34;T3\u0026#34;] ] spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.5} env.popc_epsilon = 0.416 env.popc_omega = 9.867 env.popc_sigma_T = 7.111 parameters = [ {index = 2, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, {index = 3, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, {index = 4, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, {index = 7, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, {index = 8, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, {index = 9, sigma = \u0026#34;popc_sigma_T\u0026#34;, epsilon = \u0026#34;popc_epsilon\u0026#34;, omega = \u0026#34;popc_omega\u0026#34;}, # ... ] 入力 #   \\( \\sigma \\)  と \\( \\epsilon \\)  と \\( \\omega \\)  の計算には、Lorentz-Berthelot則が用いられます。\n \\[\\sigma_{ij} = \\frac{\\sigma_i \u0026#43; \\sigma_j}{2} \\\\ \\epsilon_{ij} = \\sqrt{\\epsilon_i\\epsilon_j} \\\\ \\omega_{ij} = \\frac{\\omega_i\\omega_j}{2}\\]   index: 整数型  粒子の番号です。最初の粒子は0番目です。   offset: 整数型（省略可能）  番号のオフセットです。省略可能です。グループ内番号などを使う際に便利です。   sigma: 浮動小数点数型  粒子のサイズを指定します。   epsilon: 浮動小数点数型  ポテンシャルの強さを指定します。   omega: 浮動小数点数型  ポテンシャルの届く範囲を指定します。    このポテンシャルは \\( r = \\sqrt[6]{2}\\sigma_{ij} \u0026#43; \\omega_{ij} \\)  で正確に0となるため、カットオフには常にこの値が使用されます。 よって、cutoffを指定する必要はありません。\n入力の他の部分は、Pairを参照してください。\n"}),e.add({id:81,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondlength/WormLikeChainOffsetPotential/",title:"WormLikeChainOffset",section:"BondLength",content:"WormLikeChainOffset #  Worm-Like chain modelに基づいた、二粒子間の距離に関するオフセットを考慮したポテンシャルです。\n  \\[U(r) = \\begin{cases} 0 \u0026amp; (r \u0026lt; l_0) \\\\ \\frac{k_B T}{p} \\left(\\frac{l_c}{4} \\left[ \\frac{1}{1 - \\frac{r - l_0}{l_c}} - 1 \\right] - \\frac{r - l_0}{4} \u0026#43; \\frac{\\left(r - l_0\\right)^2}{2l_c}\\right) \u0026amp; (r \\geq l_0) \\\\ \\end{cases}\\]  例 #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;WormLikeChainOffset\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], offset = 100, p = 5.0, lc = 100.0, l0 = 30.0},  # ... ] 入力 #   p: 浮動小数点数型  ポリマーの持続長です。   lc: 浮動小数点数型  ポリマーの最大長です。   l0: 浮動小数点数型  二粒子間の距離に対してかかるオフセットです。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    Remarks #  This feature is developed by contributor, @yutakasi634.\n"}),e.add({id:82,href:"/Mjolnir/ja/docs/reference/forcefields/local/bondlength/3SPN2BondPotential/",title:"3SPN2Bond",section:"BondLength",content:"3SPN2BondPotential #  3SPN2ポテンシャルの一部分です。\n  \\[U(v) = k(v - v_0)^2 \u0026#43; 100k (v - v_0)^4\\]  例 #  [[forcefields.local]] interaction = \u0026#34;BondLength\u0026#34; potential = \u0026#34;3SPN2Bond\u0026#34; topology = \u0026#34;bond\u0026#34; parameters = [  {indices = [0, 1], offset = 100, v0 = 1.0, k = 10.0},  # ... ] 入力 #   k: 浮動小数点数型  パラメータの強さを指定します。   v0: 浮動小数点数型  最安定距離を指定します。   indices: 整数の配列型（長さ: 2）  どの粒子の間に適用するかを指定します。最初の粒子は0番めです。   offset: 整数型（省略可能）  インデックスに加算する値です。省略可能です。    "}),e.add({id:83,href:"/Mjolnir/ja/docs/reference/forcefields/global/pair/3SPN2ExcludedVolumePotential/",title:"3SPN2ExcludedVolume",section:"Pair",content:"3SPN2ExcludedVolumePotential #  3SPN2粗視化DNAモデルの排除体積ポテンシャルです。\n  \\[U(r) = \\begin{cases} \\epsilon \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - 2\\left(\\frac{\\sigma_{ij}}{r}\\right)^6\\right] \u0026#43; \\epsilon \u0026amp; (r \u0026lt; \\sigma_{ij})\\\\ 0 \u0026amp; (r \\geq \\sigma_{ij})\\\\ \\end{cases}\\]  例 #  [[forcefields.global]] interaction = \u0026#34;Pair\u0026#34; potential = \u0026#34;3SPN2ExcludedVolume\u0026#34; ignore.particles_within.bond = 1 ignore.particles_within.angle = 1 ignore.particles_within.dihedral = 1 ignore.particles_within.nucleotide = 1 spatial_partition = {type = \u0026#34;CellList\u0026#34;, margin = 0.4} parameters = [  {index = 0, kind = \u0026#34;S\u0026#34;},  {index = 1, kind = \u0026#34;A\u0026#34;},  {index = 2, kind = \u0026#34;P\u0026#34;},  {index = 3, kind = \u0026#34;S\u0026#34;}, ] 入力 #   index: 整数型  粒子のインデックスを指定します。   offset: 整数型（省略可能）  インデックスのオフセットを指定します。   kind: 文字列  以下のどれかです。 \u0026quot;S\u0026quot;(sugar) \u0026quot;P\u0026quot;(phosphate) \u0026quot;A\u0026quot;(アデニン塩基). \u0026quot;T\u0026quot;(チミン塩基). \u0026quot;C\u0026quot;(シトシン塩基). \u0026quot;G\u0026quot;(グアニン塩基).    入力の他の部分は、Pairを参照してください。\n"})})()